<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Next Generation Particle Emitters :: jMonkeyEngine Docs</title>
    <link rel="canonical" href="https://wiki.jmonkeyengine.org/docs/jme3/contributions/particles.html">
    <meta name="generator" content="Antora 2.3.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
<meta property="og:image" content="https://wiki.jmonkeyengine.org/_/img/iconx128.png">
<meta property="og:description" content="Next Generation Particle Emitters">
<meta property="og:title" content="jMonkeyEngine Docs">
<link rel="stylesheet" href="../../../_/css/site-extra.css">
<link rel="stylesheet" href="../../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://wiki.jmonkeyengine.org">
        <img alt="" src="../../../_/img/jme-logo.png" height="32" type="image/x-icon">
      </a>
      <div class="navbar-item hide-for-print">
        <input id="search-input" type="text" placeholder="Search docs">
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item theme-switch-wrapper">
          <label class="theme-switch" for="checkbox">
            <input type="checkbox" id="checkbox" />
            <div class="slider round"></div>
          </label>
        </div>
        <a class="navbar-item" href="https://github.com/jmonkeyengine/wiki">Github</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs" data-version="master">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../documentation.html">Docs</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../documentation.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="https://javadoc.jmonkeyengine.org/v3.3.2-stable">JavaDoc</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../jme3.html">jMonkeyEngine 3</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Beginner Tutorials</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_simpleapplication.html">Hello SimpleApplication</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_node.html">Hello Node</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_asset.html">Hello Asset</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_main_event_loop.html">Hello Main Event Loop</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_input_system.html">Hello Input System</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_material.html">Hello Material</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_animation.html">Hello Animation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_picking.html">Hello Picking</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_collision.html">Hello Collision</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_terrain.html">Hello Terrain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_audio.html">Hello Audio</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_effects.html">Hello Effects</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../beginner/hello_physics.html">Hello Physics</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Intermediate Tutorials</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Concepts</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/best_practices.html">Best Practices</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/simpleapplication.html">Simple Application</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../features.html">Features</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/optimization.html">Optimization</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../faq.html">FAQ</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Math Concepts</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../math_for_dummies.html">Math For Dummies</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/math.html">Math</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../math.html">More Math</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../rotate.html">Rotate</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../math_video_tutorials.html">Math Video Tutorials</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">3D Graphics Concepts</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/multi-media_asset_pipeline.html">Multi-Media Asset Pipeline</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../scenegraph_for_dummies.html">Scenegraph for Dummies</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../beginner/hellovector.html">Hello Vector</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../terminology.html">Terminology</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/how_to_use_materials.html">How to Use Materials</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/transparency_sorting.html">Transparency and Sorting</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../external/blender.html">Importing from Blender</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../external/3dsmax.html">Importing from 3DS Max</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../logo.html">Logo Usage</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../bsd_license.html">License</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../github_tips.html">Github Tips</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">SDK</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../sdk.html">jMonkeyEngine SDK</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Docs</span>
    <span class="version">master</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Docs</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../documentation.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Wiki UI</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../wiki-ui/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../documentation.html">Docs</a></li>
    <li><a href="particles.html">Next Generation Particle Emitters</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/jMonkeyEngine/wiki/edit/add-license-1/docs/modules/ROOT/pages/jme3/contributions/particles.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<h1 class="page">Next Generation Particle Emitters</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is a new particle system for jME3 posted for review and comments. This is an opportunity for people to comment on and request changes to the <abbr title="Application Programming Interface">API</abbr> or the internal functionality of the system.
The code for this particle system can be found <a href="https://github.com/jMonkeyEngine-Contributions/ParticleController">jMonkeyEngine-Contributions</a></p>
</div>
<div class="paragraph">
<p>Apologies for the slight jitter in some of the videos, the VideoRecorderState seems to be causing some issues which are not present when the application is running normally.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="credits"><a class="anchor" href="#credits"></a>Credits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>These particle emitters are inspired by and use some code from t0neg0ds particle emitters as described <a href="http://hub.jmonkeyengine.org/t/influencer-based-particleemitter-candidate-mesh-based-animated-particles/25831">here</a></p>
</div>
<div class="paragraph">
<p>Those in turn were based on the original jME3 particle system by Kirill Vainer</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-big-picture"><a class="anchor" href="#the-big-picture"></a>The Big Picture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The core of all Particle Emitters is a ParticleController. That is used to manage all of the particles, the behaviour of the particles themselves though is controlled though a number of other classes that are plugged in to the ParticleController to provide the required functionality. You can think of the ParticleController as providing the central hub into which you plug all the modules you need to get the desired behaviour.</p>
</div>
<div class="paragraph">
<p>An easy way to see what you need is to create a new ParticleController and then look at the constructor, you can see what parameters need to be supplied there.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">name</th>
<th class="tableblock halign-left valign-top">The name to use for the geometry in the scene graph</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>mesh</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The mesh to use (Usually either PointMesh or QuadMesh)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>maxParticles</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum number of particles to allow active at any one time</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>lifeMin</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The minimum amount of time (in seconds) for which each particle lives</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>lifeMax</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum amount of time (in seconds) for which each particle lives</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>source</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The source from which the particles are spawned</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>emissionController</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The frequency and timing with which particles are spawned. If null then no particles are automatically spawned and they must be triggered manually using emitNextParticle() or emitAllParticles()</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>influencers</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Zero or more ParticleInfluencers, each of which changes the behaviour of the particles.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>By selecting the behaviour you desire for each option you can configure up a virtually infinite array of possible particle emitters.</p>
</div>
<div class="paragraph">
<p>We will now walk through some common examples and possible uses, and then in the end we will document all of the possible choices for these options.</p>
</div>
<div class="paragraph">
<p>For a full reference of the standard options available see the <a href="particles/reference.html" class="page">Reference Page</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="simple-fire"><a class="anchor" href="#simple-fire"></a>Simple Fire</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HelloParticles1_SimpleFire extends SimpleApplication {

    public static void main(String[] args){
        HelloParticles1_SimpleFire app = new HelloParticles1_SimpleFire();
        app.start(); // start the game
    }

    @Override
    public void simpleInitApp() {

// Construct a new ParticleController
        ParticleController pCtrl = new ParticleController(
// The name of the emitter
                "SimpleFire",
// Use a simple point mesh (the fastest but most limitted mesh type) with the specified
// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.
                new PointMesh(assetManager, "Effects/Explosion/flame.png", 2, 2),
// Allow at most 32 particles at any time
                32,
// Particles last for at least 2 seconds
                2,
// And at most 3 seconds
                3,
// Point sources always generate particles at the location of the source, the particles
// are given a random velocity between the two given.
                new PointSource(new Vector3f(-3, 0, -3), new Vector3f(3, 0, 3)),
// Emit particles at regular intervals, 10 particles every second
                new RegularEmission(10),
// ** Influencers start here
// Select a random sprite from the 4 available for each particle
                new RandomSpriteInfluencer(),
// Particles start off with a size of 0.5 units, end with a radius of 0.1
                new SizeInfluencer(0.5f, 0.1f),
// Particles start yellow full opacity and fade towards red with very low opacity
                new ColorInfluencer(new ColorRGBA(1,1,0.2f,1), new ColorRGBA(1,0,0,0.1f)),
// No matter what velocity particles started with they will start moving upwards.
                new PreferredDirectionInfluencer(new Vector3f(0, 1, 0), 0.25f));

// Finally attach the geometry to the rootNode in order to start the particles running
        rootNode.attachChild(pCtrl.getGeometry());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run that and the result should look something like:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../_images/jme3/particles1.jpg" alt="particles1.jpg" width="" height=""></span></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="simple-fire-and-smoke"><a class="anchor" href="#simple-fire-and-smoke"></a>Simple Fire and Smoke</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Override
    public void simpleInitApp() {

// Construct a new ParticleController
        ParticleController pCtrl = new ParticleController(
// The name of the emitter
                "SimpleFire",
// Use a simple point mesh (the fastest but most limitted mesh type) with the specified
// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.
                new PointMesh(assetManager, "Effects/Explosion/flame.png", 2, 2),
// Allow at most 50 particles at any time, the particles are lasting longer this time
// so we need to allow more on screen at once
                50,
// Particles last for at least 4 seconds
                4,
// And at most 5 seconds
                5,
// Point sources always generate particles at the location of the source, the particles
// are given a random velocity between the two given.
                new PointSource(new Vector3f(-3, 0, -3), new Vector3f(3, 0, 3)),
// Emit particles at regular intervals, 10 particles every second
                new RegularEmission(10),
// ** Influencers start here
// Select a random sprite from the 4 available for each particle
                new RandomSpriteInfluencer(),
// Particles start off with a size of 0.5 units, end with a radius of 0.1
                new SizeInfluencer(0.5f, 0.25f),
// Particles start yellow full opacity and fade towards red with very low opacity
                new MultiColorInfluencer(
                    new MultiColorInfluencer.Stage(0, new ColorRGBA(1, 1, 0.1f, 1)),
                    new MultiColorInfluencer.Stage(0.15f, new ColorRGBA(1, 0, 0, 0.25f)),
                    new MultiColorInfluencer.Stage(0.3f, new ColorRGBA(1f, 1f, 1f, 0.5f)),
                    new MultiColorInfluencer.Stage(1, new ColorRGBA(1f,1f,1f,0f))
                ),
// No matter what velocity particles started with they will start moving upwards.
                new PreferredDirectionInfluencer(new Vector3f(0, 1, 0), 0.25f));

// Finally attach the geometry to the rootNode in order to start the particles running
        rootNode.attachChild(pCtrl.getGeometry());
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that the only change is to make the particles last a little longer and to change the ColorInfluencer for a MultiColorInfluencer, and yet the results look quite different:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../_images/jme3/particles2.jpg" alt="particles2.jpg" width="" height=""></span></p>
</div>
<div class="paragraph">
<p>This isn&#8217;t a very convincing fire yet, but it is very simple to get up and running. One problem with this approach is that particles are done using an alpha-additive material, they can only make things brighter but never darker. That is not ideal for smoke which should be able to make them darker too. We will look at this again later but for now we will move on to some different mesh types.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quad-meshes-and-billboarding"><a class="anchor" href="#quad-meshes-and-billboarding"></a>Quad Meshes and Billboarding</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Point Meshes are extremely fast, but they have a number of limitations. The main ones being that the sprites must always be facing towards the screen and that on certain graphics cards the maximum number of pixels a sprite can occupy on the screen is limited.</p>
</div>
<div class="paragraph">
<p>While PointMesh is recommended for basic particles for more advanced options there is the QuadMesh, this constructs each particle using a quad and as a result can allow any size on the screen and any orientation. The following example combines two separate particle emitters to produce a spell-like effect.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The flame image from before is used for the second emitter, the first emitter uses this image which you can download and use:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../_images/jme3/runecircle.png" alt="runecircle.png" width="256" height=""></span></p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Override
    public void simpleInitApp() {

// Construct a new ParticleController to provide the actual spell runes effect
        ParticleController pCtrl = new ParticleController(
// The name of the emitter
                "SpellRunes",
// Use a Quad Mesh, this image is available for download on this page. The texture file contains
// a single image so there are no sprite columns and rows to set up. The BillboardStrategy is how
// the particles should be oriented, in this case it uses the particle rotation.
                new QuadMesh(QuadMeshBillboardStrategy.USE_PARTICLE_ROTATION, assetManager, "Textures/runeCircle.png"),
// Allow at most 9 particles at any time
                9,
// Particles always last for 4 seconds
                4,
                4,
// We want to generate all particles from the same location with the same velocity.
                new PointSource(new Vector3f(0, 1f, 0), new Vector3f(0, 1f, 0)),
// Emit particles at regular intervals, 4 particles every second
                new RegularEmission(2),
// ** Influencers start here
// These particles should be size 3 and stay the same size
                new SizeInfluencer(3, 3),
// Start the particles at full opacity blue and then fade them out to 0 opacity cyan.
                new ColorInfluencer(ColorRGBA.Blue, new ColorRGBA(0, 1, 1, 0)),
// Rotate all particles by the same amount. The units are radians-per-second
                new RotationInfluencer(
                    new Vector3f(0, FastMath.QUARTER_PI, 0),
                    new Vector3f(0, FastMath.QUARTER_PI, 0), false));

// Finally attach the geometry to the rootNode in order to start the particles running
        rootNode.attachChild(pCtrl.getGeometry());


// Construct a new ParticleController to provide the central glow effect
        pCtrl = new ParticleController(
// The name of the emitter
                "SpellBase",
// Use a simple point mesh (the fastest but most limitted mesh type) with the specified
// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.
                new PointMesh(assetManager, "Textures/flame.png", 2, 2),
// Allow at most 76 particles at any time
                76,
// Particles last for at least 5 seconds
                5,
// And at most 5 seconds
                5,
// Point sources always generate particles at the location of the source, the particles
// are given a random velocity between the two given.
                new PointSource(new Vector3f(-1f, 0, -1f), new Vector3f(1f, 0.5f, 1f)),
// Emit particles at regular intervals, 15 particles every second
                new RegularEmission(15),
// ** Influencers start here
// Select a random sprite from the 4 available for each particle
                new RandomSpriteInfluencer(),
// Particles start red with some blue and green and fade towards blue zero opacity
// Because particles are rendered using an additive blend then any area where a lot
// of particles overlap will end up white.
                new ColorInfluencer(new ColorRGBA(1,0.25f,0.25f,0.25f), new ColorRGBA(0,0,1,0f)));

// Finally attach the geometry to the rootNode in order to start the particles running
        rootNode.attachChild(pCtrl.getGeometry());


        cam.setLocation(new Vector3f(0, 10, -10));
        cam.lookAt(Vector3f.ZERO, Vector3f.UNIT_Y);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result should look something like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=_Spjqag99HY">Video: Particle Emitter Example 1</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-a-mesh-as-the-particle-source"><a class="anchor" href="#using-a-mesh-as-the-particle-source"></a>Using a mesh as the particle source</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There is a model of a monkeys head in the test data that is used in this example, although you can use any other model you like. Just make sure you can find the geometry within the model for the next step.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Override
    public void simpleInitApp() {

        Node monkey = (Node) assetManager.loadModel("Models/MonkeyHead/MonkeyHead.mesh.xml");
        rootNode.attachChild(monkey);

        DirectionalLight dl = new DirectionalLight();
        dl.setDirection(new Vector3f(-0.1f,-0.7f,-1).normalizeLocal());
        dl.setColor(new ColorRGBA(0.88f, 0.60f, 0.60f, 1.0f));
        rootNode.addLight(dl);

        AmbientLight al = new AmbientLight();
        al.setColor(ColorRGBA.White);
        rootNode.addLight(al);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result should look something like:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../../_images/jme3/particles3.jpg" alt="particles3.jpg" width="" height=""></span></p>
</div>
<div class="paragraph">
<p>Now lets set fire to the monkey! (No monkeys were harmed during the making of this particle system!).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Construct a new ParticleController
        ParticleController pCtrl = new ParticleController(
// The name of the emitter
                "SimpleFire",
// Use a simple point mesh (the fastest but most limitted mesh type) with the specified
// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.
                new PointMesh(assetManager, "Textures/flame.png", 2, 2),
// Allow at most 1200 particles at any time, the particles are lasting longer this time
// so we need to allow more on screen at once
                1200,
// Particles last for at least 4 seconds
                4,
// And at most 5 seconds
                5,
// A MeshSource scans a geometry and picks a random point on the surface of that
// geometry in order to emit the particle from it. The particle has an inital velocity
// of 1wu/s along the normal of the triangle from which it is emitted.
                new MeshSource(g),
// Emit particles at regular intervals, 10 particles every second
                new RegularEmission(240),
// ** Influencers start here
// Select a random sprite from the 4 available for each particle
                new RandomSpriteInfluencer(),
// Particles start off with a size of 0.1 units, end with a size of 0.15
                new SizeInfluencer(0.1f, 0.15f),
// Particles have a constant speed of 0.25f, this will modify the original speed
// from the emitter and then allow the GravityInfluencer to change the direction
// of motion but constrain the speed
                new SpeedInfluencer(0.25f, 0.25f),
// Fade the paticles through a range of colours
                new MultiColorInfluencer(
                    new MultiColorInfluencer.Stage(0, new ColorRGBA(1, 1, 0.1f, 1)),
                    new MultiColorInfluencer.Stage(0.25f, new ColorRGBA(1, 0, 0, 0.25f)),
                    new MultiColorInfluencer.Stage(0.5f, new ColorRGBA(1f, 1f, 1f, 0.25f)),
                    new MultiColorInfluencer.Stage(1, new ColorRGBA(1f,1f,1f,0f))
                ),
// No matter what velocity particles started with they will start moving upwards.
                new GravityInfluencer(new Vector3f(0, 0.5f, 0)));

// Finally attach the geometry to the rootNode in order to start the particles running
        rootNode.attachChild(pCtrl.getGeometry());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again this is just a very simple example, much more sophisticated fire effects are possible with the use of the right textures and mixture of emitters and influencers. The result though should look something like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=W__zGJHZ2AU">Video: Particle Emitter Example 2</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="meshes-and-weighted-meshes"><a class="anchor" href="#meshes-and-weighted-meshes"></a>Meshes and Weighted Meshes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The previous example uses a MeshSource, this picks a random triangle from the mesh without any regard given to the size of different triangles. This means areas with small triangles are actually more likely to emit particles than areas with large triangles. For most meshes this is not visible, however there is a WeightedMeshSource available if this should be a problem.</p>
</div>
<div class="paragraph">
<p>The WeightedMeshSource scans the mesh and works out a weight for each triangle based on its relative size, so that the result is an even spread of particles even with very large differences in triangle sizes. There are some limitations with this though:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The WeightedMeshSource consumes more memory as it needs to remember the weights</p>
</li>
<li>
<p>The WeightedMeshSource is slower as it needs to do more work to pick a triangle</p>
</li>
<li>
<p>The WeightedMeshSource does not update automatically if the mesh changes, if triangles are added they will not emit, if triangles are removed it could cause a crash. If triangles change shape then the weights are not updated.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There is a method available to cause the weights to be recalculated which can be used if changing the mesh, but really if possible a non-weighted MeshSource should be used for dynamic meshes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="3d-particles-templatemesh"><a class="anchor" href="#3d-particles-templatemesh"></a>3d Particles - TemplateMesh</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The previous mesh examples all use simple 2d quads to display images. There is another mesh type though, the TemplateMesh, which allows fully featured 3d particles to be used.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There is a rock texture available in the jME3 test data, or you can substitute any other suitable texture. The model for this example is: <a href="http://www.zero-separation.com/particles/FracturedCube.j3o">FracturedCube.j3o</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Override
    public void simpleInitApp() {

        // Since we actually use a full lit material for these particles we need
        // to add a light to the scene in order to see anything.
        DirectionalLight dl = new DirectionalLight();
        dl.setDirection(new Vector3f(-0.1f,-0.7f,-1).normalizeLocal());
        dl.setColor(new ColorRGBA(0.6f, 0.60f, 0.60f, 1.0f));
        rootNode.addLight(dl);

// A standard lit material is used, this rock texture was taking from the
// jme3 test data but you can easily substitute your own.
        Material rock = new Material(assetManager, "Common/MatDefs/Light/Lighting.j3md");
        rock.setTexture("DiffuseMap", assetManager.loadTexture("Textures/Rock.PNG"));
        rock.setFloat("Shininess", 100f);

// A PointSource is actually a fully featured Spatial object, in this case
// we simply adjust its translation, but it can actually be attached to the
// scene graph and the source will automatically move as the Node to which
// it is attached is transformed.
        PointSource source = new PointSource(new Vector3f(-5,-5,-5), new Vector3f(5,5,5));
        source.setLocalTranslation(0, 10, -20);

// A TemplateMesh uses any number of standard meshes to be the template for
// each 3d particle. This model was generated simply by taking a cube in
// Blender and running a fracture script on it to generate 20 fragments.
        Node n = (Node) assetManager.loadModel("Models/FracturedCube.j3o");
        Mesh[] templates = new Mesh[n.getChildren().size()];
        int i = 0;
        for (Spatial s: n.getChildren()) {
            Geometry g = (Geometry)((Node)s).getChild(0);
            templates[i++] = g.getMesh();
        }

// Construct the new particle controller
        ParticleController rockCtrl = new ParticleController(
                "TemplateMesh",
// The TemplateMesh uses the rock material we created previously, the two boolean
// flags say that we are not interested in vertex colours but we do want the vertex
// normals. The array of meshes extracted from the model is then passed in to use
// as models for each particle.
                new TemplateMesh(rock, false, true, templates),
// A maximum of 64 particles at once, each lasting for 5 to 5.5 seconds.
                64,
                5,
                5.5f,
// Particles are emitted from the source that we created and positioned earlier
                source,
// Emit 8 particles per second
                new RegularEmission(8),
// The "sprites" in this case are the available templates. The TemplateMesh has
// one spriteColumn for each template it has been provided, so the standard
// RandomSpriteInfluencer just causes one to be picked at random each time a
// particle is emitted.
                new RandomSpriteInfluencer(),
// Rocks fall.
                new GravityInfluencer(new Vector3f(0, -4, 0)),
// Rocks spin.
                new RotationInfluencer(new Vector3f(-2, -2, -2), new Vector3f(2, 2, 2), false));

        rootNode.attachChild(rockCtrl.getGeometry());
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result should look like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=a7y53UF8Giw">Video: Particle Emitter Example 3</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any number and mixture of models can be used, although as it is all a single mesh the same material must be used for all of them. It is recommended to keep a similar number of vertices for each of the models but that is not a strict requirement.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="emitting-particles-from-particles"><a class="anchor" href="#emitting-particles-from-particles"></a>Emitting Particles from Particles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To add more dramatic effects sometimes you want to emit particles from particles, this could be done simply by attaching a MeshSource for the second controller to the mesh from the first controller. There are a number of limitations to this approach though, which will be demonstrated now:</p>
</div>
<div class="paragraph">
<p>Adding the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        ParticleController pCtrl = new ParticleController(
                "TemplateFlames",
                new PointMesh(assetManager, "Textures/flame.png", 2, 2),
                1300,
                3,
                4,
                new MeshSource(rockCtrl.getGeometry()),
                new RegularEmission(320),
                new SizeInfluencer(0.5f, 2),
                new ColorInfluencer(new ColorRGBA(1,1,0.1f, 1f), new ColorRGBA(1,0,0,0.05f)),
                new GravityInfluencer(new Vector3f(0, 0.3f, 0)),
                new RandomImpulseInfluencer(
                    RandomImpulseInfluencer.ImpulseApplicationTime.INITIALIZE,
                    new Vector3f(-0.5f, -0.5f, -0.5f),
                    new Vector3f(0.5f, 0.5f, 0.5f)));

        rootNode.attachChild(pCtrl.getGeometry());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Results in something that looks like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=WGR5RzF9APg">Video: Particle Emitter Example 3</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can see that while dramatic the fire is left behind each particle, this is because although it is emitted from the face of the particle at its current position it has no knowledge of how that particle is moving.</p>
</div>
<div class="paragraph">
<p>To allow for this we also offer a different emitter, this allows one ParticleController to act as the source for another. The emitted particles are then able to start with the same velocity and rotation of the particle they are being emitted from and then move onwards from there as appropriate.</p>
</div>
<div class="paragraph">
<p>Leave everything else the same but change the MeshSource into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">                new ParticleParticleSource(rockCtrl),</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that this gives much better results:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=2BlBZVM0EZQ">Video: Particle Emitter Example 4</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is a lot of falling rocks and fire here, but not much in the way of smoke. That could be added using a multi-colour emitter as previously, but the standard particle material is additive. That means it can only make colours brighter, never darker. For smoke it should be able to darken as well as lighten.</p>
</div>
<div class="paragraph">
<p>To add smoke we can add a third emitter after the other two:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Construct a new material for the smoke based off the default particle material
        Material smokeMat = new Material(
               assetManager, "Common/MatDefs/Misc/Particle.j3md");
// The Smoke.png texture can be found in the jme3 test data
        smokeMat.setTexture("Texture",
            assetManager.loadTexture("Textures/Smoke.png"));
// Set the blend mode to Alpha rather than AlphaAdditive so that dark smoke
// can darken the scene behind it
        smokeMat.getAdditionalRenderState().setBlendMode(RenderState.BlendMode.Alpha);
// For point sprite meshes this parameter must be set
        smokeMat.setBoolean("PointSprite", true);

// Construct the new particle controller
        pCtrl = new ParticleController(
                "TemplateSmoke",
// The Smoke.png texture contains 15 sprites, if you use a different texture adjust
// these parameters accordingly.
                new PointMesh(smokeMat, 15, 1),
                800,
                4,
                5,
                new ParticleParticleSource(rockCtrl),
                new RegularEmission(180),
                new SizeInfluencer(1f, 2.5f),
                new MultiColorInfluencer(
                    new MultiColorInfluencer.Stage(0, new ColorRGBA(1, 1, 1, 0)),
                    new MultiColorInfluencer.Stage(0.5f, new ColorRGBA(0, 0, 0, 0.5f)),
                    new MultiColorInfluencer.Stage(1, new ColorRGBA(1, 1, 1, 0))),
                new GravityInfluencer(new Vector3f(0, 0.75f, 0)),
                new RandomImpulseInfluencer(
                    RandomImpulseInfluencer.ImpulseApplicationTime.INITIALIZE,
                    new Vector3f(-0.5f, -0.5f, -0.5f),
                    new Vector3f(0.5f, 0.5f, 0.5f)));

        rootNode.attachChild(pCtrl.getGeometry());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The results look something like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=01qCBGBvf-c">Video: Particle Emitter Example 5</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To complete the effect one final line of code adds a skybox (using another texture that can be find in the test data):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        rootNode.attachChild(SkyFactory.createSky(assetManager, "Textures/BrightSky.dds", false));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we have the final effect which looks like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=uDeWAjw4LxU">Video: Particle Emitter Example 6</a></p>
</li>
</ul>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>Copyright 2020 jMonkeyEngine Wiki Contributors. Licensed BSD-3.</p>
</footer>
<script src="../../../_/js/vendor/docsearch.min.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
var search = docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#search-input',
  autocompleteOptions: { hint: false, keyboardShortcuts: ['s'] },
  algoliaOptions: { hitsPerPage: 10 }
}).autocomplete
search.on('autocomplete:closed', function () { search.autocomplete.setVal() })
function focusSearchInput () { document.querySelector('#search-input').focus() }
if (document.querySelector('.home-link.is-current')) window.addEventListener('load', focusSearchInput)
</script>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
