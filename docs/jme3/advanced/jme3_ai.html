<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>jMonkeyEngine Artificial Intelligence :: jMonkeyEngine Docs</title>
    <link rel="canonical" href="https://wiki.jmonkeyengine.org/docs/jme3/advanced/jme3_ai.html">
    <meta name="generator" content="Antora 2.3.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
<meta property="og:image" content="https://wiki.jmonkeyengine.org/_/img/iconx128.png">
<meta property="og:description" content="jMonkeyEngine Artificial Intelligence">
<meta property="og:title" content="jMonkeyEngine Docs">
<link rel="stylesheet" href="../../../_/css/site-extra.css">
<link rel="stylesheet" href="../../../_/css/vendor/docsearch.min.css">
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css -->
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://wiki.jmonkeyengine.org">
        <img alt="" src="../../../_/img/jme-logo.png" height="32" type="image/x-icon">
      </a>
      <div class="navbar-item hide-for-print">
        <input id="search-input" type="text" placeholder="Search docs">
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item theme-switch-wrapper">
          <label class="theme-switch" for="checkbox">
            <input type="checkbox" id="checkbox" />
            <div class="slider round"></div>
          </label>
        </div>
        <a class="navbar-item" href="https://github.com/jmonkeyengine/wiki">Github</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs" data-version="master">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../documentation.html">Docs</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../documentation.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="https://javadoc.jmonkeyengine.org/v3.3.2-stable">JavaDoc</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../jme3.html">jMonkeyEngine 3</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Intermediate Tutorials</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Concepts</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/best_practices.html">Best Practices</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/simpleapplication.html">Simple Application</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../features.html">Features</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/optimization.html">Optimization</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../faq.html">FAQ</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Math Concepts</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../math_for_dummies.html">Math For Dummies</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/math.html">Math</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../math.html">More Math</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../rotate.html">Rotate</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../math_video_tutorials.html">Math Video Tutorials</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">3D Graphics Concepts</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/multi-media_asset_pipeline.html">Multi-Media Asset Pipeline</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../scenegraph_for_dummies.html">Scenegraph for Dummies</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../../tutorials/beginner/hellovector.html">Hello Vector</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../terminology.html">Terminology</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/how_to_use_materials.html">How to Use Materials</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/transparency_sorting.html">Transparency and Sorting</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../external/blender.html">Importing from Blender</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../external/3dsmax.html">Importing from 3DS Max</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../logo.html">Logo Usage</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../bsd_license.html">License</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../github_tips.html">Github Tips</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">SDK</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../sdk.html">jMonkeyEngine SDK</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Tutorials</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../tutorials/beginner/beginner.html">Beginner tutorials</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_simpleapplication.html">Hello SimpleApplication</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_node.html">Hello Node</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_asset.html">Hello Asset</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_main_event_loop.html">Hello Update Loop</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_input_system.html">Hello Input System</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_material.html">Hello Material</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_animation.html">Hello Animation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_picking.html">Hello Picking</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_collision.html">Hello Collision</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_terrain.html">Hello Terrain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_audio.html">Hello Audio</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_effects.html">Hello Effects</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_physics.html">Hello Physics</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Docs</span>
    <span class="version">master</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Docs</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../documentation.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Wiki UI</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../wiki-ui/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../documentation.html">Docs</a></li>
    <li><a href="jme3_ai.html">jMonkeyEngine Artificial Intelligence</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/jMonkeyEngine/wiki/edit/master/docs/modules/ROOT/pages/jme3/advanced/jme3_ai.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<h1 class="page">jMonkeyEngine Artificial Intelligence</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Most games written need some type of <a href="https://en.wikipedia.org/wiki/Artificial_intelligence_(video_games)">Artificial Intelligence</a> to deliver a feeling of realism, excitement or challenge to the player. AI can be as simple as having an NPC (Non Player Character) respond to some action taken by a player or as complicated as smoothly navigating your way through a scene full of obstacles without getting stuck. It&#8217;s a time-consuming and significant challenge to develop these systems so its much easier to use an existing library to do the heavy lifting for you.</p>
</div>
<div class="paragraph">
<p>Unfortunately, the jMonkeyEngine comes with no official library for dealing with AI. There is, however, the jme3 Artificial Intelligence library that is probably the closest there is to an official release. Although it never made it into any official releases, it was designed, in part, by core team members. It consists of two separate AI models, a <a href="https://en.wikipedia.org/wiki/Navigation_mesh">Navigation Mesh</a> library using <a href="https://en.wikipedia.org/wiki/Pathfinding">path-finding</a>, and a simple Steering Behaviours library that uses path-following.</p>
</div>
<div class="paragraph">
<p>You can read about the introduction of the library in the forum thread: <a href="https://hub.jmonkeyengine.org/t/ai-plugin-now-with-navmesh-pathfinding/24644">AI plugin now with NavMesh path-finding</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="requirements"><a class="anchor" href="#requirements"></a>Requirements</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/MeFisto94/jme3-artificial-intelligence/releases">jme3 Artificial Intelligence Library</a> - The library and javaDocs for jme3AI. This is also where you can report problems or help in maintaining the library.</p>
</li>
<li>
<p><a href="https://github.com/stevefsp/critterai/releases">CritterAI</a> - Stephen Pratt&#8217;s <a href="http://www.critterai.org/projects/nmgen_study/">NMGen Study</a> project files to generate the navmesh.</p>
</li>
<li>
<p>To get the assets (3D models) used in this example, add the <a href="../../sdk/sample_code.html#jme3testdata-assets#" class="page">jME3-testdata.jar</a> to your classpath.</p>
</li>
<li>
<p>Java SDK 8+.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Stephen Pratt explains in detail the configuration parameters of CritterAI/Jme3AI in a easy to follow format and is suggested reading.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.critterai.org/projects/nmgen_study/config.html">Configuration Parameters</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use-example"><a class="anchor" href="#use-example"></a>Use Example</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The jme3 Artificial Intelligence Library contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NavMesh - A Navigation Mesh path-finding AI system using the <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A*</a> algorithm.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</li>
<li>
<p>Steering - The foundations of an <a href="http://natureofcode.com/book/chapter-6-autonomous-agents/">Autonomous Agent</a> system that uses path-following and forces to move a character through its environment. Includes a test case as well.<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This scope of this tutorial is restricted to the NavMesh part of the library and expands upon the lessons taught in the <a href="../../jme3.html#tutorials-for-beginners" class="page">tutorials</a>. It demonstrates the use of some classes and methods found in the Medium and Advanced topics of the wiki as well. You can find the source code for this tutorial in the  <a href="https://github.com/jMonkeyEngine/doc-examples/tree/master/src/com/jme3/examples/jme3ai">jMonkeyEngine/docs-examples</a> repository.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Moving a character through your scene requires three things.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A navigation mesh.</p>
</li>
<li>
<p>A path-finding component that uses that navigation mesh to calculate a path.</p>
</li>
<li>
<p>A way to move the character.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="navmesh-creation"><a class="anchor" href="#navmesh-creation"></a>NavMesh Creation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The first thing you need for path-finding is a navigation mesh. There are two ways to generate the NavMesh, procedural or the jMonkey <a href="https://github.com/jMonkeyEngine/sdk/releases">SDK</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The SDK has a built-in command, but comes with a trade-off that no parameter exceptions are thrown. This means you are flying blind when the NavMesh fails generation.</p>
</li>
<li>
<p>If you choose procedural, you see any generation exceptions, but you will have to do a little more work like saving, loading and/or displaying the NavMesh.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both methods produce exactly the same NavMesh and both will be covered in this tutorial.</p>
</div>
<div class="sect2">
<h3 id="from-the-sdk"><a class="anchor" href="#from-the-sdk"></a>From the SDK</h3>
<div class="ulist">
<ul>
<li>
<p>Open your scene in the Terrain Editor or Scene Explorer by <b class="button">RMB</b> selecting the file in your assets folder and choosing <code>Edit Terrain</code> or <code>Edit in SceneComposer</code>.</p>
</li>
<li>
<p>Once open, <b class="button">RMB</b> select the root node in the <code>SceneExplorer</code> and then select <code><span class="menuseq"><b class="menu">Spatial</b>&#160;<i class="fa fa-angle-right caret"></i> <b class="menuitem">NavMesh</b></span></code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This will open the <code>Create NavMesh</code> dialog with default settings. You can read in depth about each parameter by following the <code>Configuration Parameters</code> link under <a href="#requirements#">Requirements</a>.</p>
</div>
<div class="paragraph">
<div class="title">Parameter Insight</div>
<p>The jme3AI system uses CritterAI, which is based off <a href="https://github.com/recastnavigation/recastnavigation">Recast and Detour</a> navigation. The author of Recast lays out a few specific rules for NavMesh creation in this <a href="http://digestingduck.blogspot.dk/2009/08/recast-settings-uncovered.html">blog post</a>, which logically apply to jme3AI. Below is a translation of this post as it pertains to jme3AI.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First you should decide the size of your character "capsule". For example, if you are using meters as units in your game world, a good size of human sized character might be (r)adius=0.4, (h)eight=2.0.</p>
</li>
<li>
<p>Next the voxelization cell size (cs) will be derived from that. Usually good value for cs is r/2 or r/3. In outdoor environments, r/2 might be enough, indoors you sometimes want the extra precision and you might choose to use r/3 or smaller.</p>
</li>
<li>
<p>The voxelization cell height (ch) is defined separately in order to allow greater precision in height tests. Good starting point for ch is cs/2. If you get small holes where there are discontinuities in the height (steps), you may want to decrease cell height.</p>
</li>
<li>
<p>Next up is the character definition values. First up is <code>minTraversableHeight</code>, which defines the height of the agent.</p>
</li>
<li>
<p>The <code>maxTraversableStep</code> defines how high steps the character can climb.</p>
</li>
<li>
<p>The parameter <code>traversableAreaBorderSize</code> defines the agent radius. If this value is greater than zero, the navmesh will be shrunken by the <code>traversableAreaBorderSize</code>. If you want to have tight fit navmesh, use zero radius.</p>
</li>
<li>
<p>The parameter <code>maxTraversableSlope</code> is used before voxelization to check if the slope of a triangle is too high and those polygons will be given a non-walkable flag. The parameter is in radians.</p>
</li>
<li>
<p>In certain cases really long outer edges may decrease the triangulation results. Sometimes this can be remedied by just tessellating the long edges. The parameter <code>maxEdgeLength</code> defines the max
edge length. A good value for <code>maxEdgeLength</code> is something like <code>traversableAreaBorderSize*8</code>. A good way to tweak this value is to first set it really high and see if your data creates long edges. If so, then try to find as big value as possible which happen to create those few extra vertices which makes the tessellation better.</p>
</li>
<li>
<p>When the rasterized areas are converted back to vectorized representation the <code>edgeMaxDeviation</code> describes how loosely the simplification is done.  Good values are between 1.1-1.5 (1.3 usually yield good results). If the value is less, some stair-casing starts to appear at the edges and if it is more than that, the simplification starts to cut some corners.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A summary of the parameter effects is included in the comments of the <a href="https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavMeshState.java">NavMeshState.java</a> file and discussed in the Procedural code examples that follow this section.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If there are problems with your parameter settings, you will only know if the NavMesh doesn&#8217;t appear under the Node you selected and there is no task running in the status area located at the bottom right of the SDK.</p>
</div>
<div class="paragraph">
<p>If the NavMesh doesn&#8217;t appear, then you will have to make adjustments to the <code>Configuration Parameters</code> until it completes successfully. Minor adjustments to cell size will usually work.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Cell size has the greatest impact on your NavMesh. The smaller the cell size, the more accurate the NavMesh, the longer it takes to generate. Generating a 1024x1024 NavMesh can take anywhere from 30 seconds to ten minutes to complete, depending on terrain complexity. Even larger NavMeshes can take many hours.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Selecting the NavMesh node in the SceneExplorer will show the NavMesh in the Terrain Editor or SceneComposer view-port. If it doesn&#8217;t show, with the NavMesh node selected, change the <code>Cull Hint</code> to <code>Never</code> in the <code>NavMesh - Properties</code> panel.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="procedural-method"><a class="anchor" href="#procedural-method"></a>Procedural Method</h3>
<div class="paragraph">
<p>There are many ways to create a NavMesh. If you look at the constructor for the <a href="https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/Jme3AI.java">Jme3AI.java</a> file, you will see I use a <a href="application_states.html#baseappstate#" class="page">BaseAppState</a> named <a href="https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavMeshState.java">NavMeshState.java</a> which creates a <code>generator</code> object and builds the <code>NavMesh</code> new every time the program is ran.</p>
</div>
<div class="listingblock">
<div class="title">Jme3AI constructor</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Jme3AI() {
    super(new StatsAppState(), new DebugKeysAppState(), new TerrainState(),
            new NavMeshState(), new PCState(), new KeyboardRunState());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It can take from seconds to hours to build a NavMesh, depending on how complicated it is. Therefore, you would normally build the NavMesh or meshes, add them to your <code>Assets</code> folder and load them at startup. The <code>NavMeshState</code> and <code>NavMeshGenerator</code> classes are both convenience classes and are not required to create a NavMesh. If you wish to keep your game minimalist, you can set the variables for the CritterAI NavmeshGenerator (note the lower case 'm' in mesh) in the method call directly or by variable, and pass the IndexBuffer and VertexBuffer of your mesh into the CritterAI NavmeshGenerator object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">NavmeshGenerator nmgen = new NavmeshGenerator(cellSize, cellHeight, minTraversableHeight,
                maxTraversableStep, maxTraversableSlope,
                clipLedges, traversableAreaBorderSize,
                smoothingThreshold, useConservativeExpansion,
                minUnconnectedRegionSize, mergeRegionSize,
                maxEdgeLength, edgeMaxDeviation, maxVertsPerPoly,
                contourSampleDistance, contourMaxDeviation);
...
Get mesh buffers and set IntermediateData
...

//Pass buffers and IntermediateData to build process
TriangleMesh triMesh = nmgen.build(positions, indices, intermediateData);

...
Process trimesh
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s examine what it takes to create the <code>NavMesh</code> using the <code>NavMeshState</code> and <code>NavMeshGenerator</code> helper classes.</p>
</div>
<div class="listingblock">
<div class="title">NavMeshState NavMesh generation method</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * creates the NavMesh
 */
private void createNavMesh() {
    generator = new NavMeshGenerator();
    //The width and depth resolution used when sampling the source geometry.
    //outdoors = agentRadius/2, indoors = agentRadius/3, cellSize =
    //agentRadius for very small cells.
    //Constraints &gt; 0 , default=1
    generator.setCellSize(.25f);
    //The height resolution used when sampling the source geometry.
    //minTraversableHeight, maxTraversableStep, and contourMaxDeviation
    //will need to be greater than the value of cellHeight in order to
    //function correctly. maxTraversableStep is especially susceptible to
    //impact from the value of cellHeight.
    //cellSize/2
    //Constraints &gt; 0, default=1.5
    generator.setCellHeight(.125f);
    //Represents the minimum floor to ceiling height that will still allow
    //the floor area to be considered traversable.
    //minTraversableHeight should be at least two times the value of
    //cellHeight in order to get good results. Max spatial height.
    //Constraints &gt; 0, default=7.5
    generator.setMinTraversableHeight(2f);
    //Represents the maximum ledge height that is considered to still be
    //traversable.
    //maxTraversableStep should be greater than two times cellHeight.
    //Constraints &gt;= 0, default=1
    generator.setMaxTraversableStep(0.3f);
    //The maximum slope that is considered traversable. (In degrees.)
    //Constraints &gt;= 0, default=48
    generator.setMaxTraversableSlope(50.0f);
    //Indicates whether ledges should be considered un-walkable.
    //Constraints None, default=false
    generator.setClipLedges(false);
    //Represents the closest any part of a mesh can get to an obstruction in
    //the source geometry.
    //traversableAreaBorderSize value must be greater than the cellSize to
    //have an effect. Radius of the spatial.
    //Constraints &gt;= 0, default=1.2
    generator.setTraversableAreaBorderSize(0.6f);
    //The amount of smoothing to be performed when generating the distance
    //field used for deriving regions.
    //Constraints &gt;= 0, default=2
    generator.setSmoothingThreshold(0);
    //Applies extra algorithms to help prevent malformed regions from
    //forming.
    //Constraints None, default=true
    generator.setUseConservativeExpansion(true);
    //The minimum region size for unconnected (island) regions.
    //Constraints &gt; 0, default=3
    generator.setMinUnconnectedRegionSize(8);
    //Any regions smaller than this size will, if possible, be merged with
    //larger regions.
    //Constraints &gt;= 0, default=10
    generator.setMergeRegionSize(20);
    //The maximum length of polygon edges that represent the border of
    //meshes.
    //setTraversableAreaBorderSize * 8
    //Constraints &gt;= 0, default=0
    generator.setMaxEdgeLength(4.0f);
    //The maximum distance the edges of meshes may deviate from the source
    //geometry.
    //1.1 to 1.5 for best results.
    //Constraints &gt;= 0 , default=2.4
    generator.setEdgeMaxDeviation(1.3f);
    //The maximum number of vertices per polygon for polygons generated
    //during the voxel to polygon conversion process.
    //Constraints &gt;= 3, default=6
    generator.setMaxVertsPerPoly(6);
    //Sets the sampling distance to use when matching the detail mesh to the
    //surface of the original geometry.
    //Constraints &gt;= 0, default=25
    generator.setContourSampleDistance(5.0f);
    //The maximum distance the surface of the detail mesh may deviate from
    //the surface of the original geometry.
    //Constraints &gt;= 0, default=25
    generator.setContourMaxDeviation(5.0f);
    //Time allowed before generation process times out in miliseconds.
    //default=10000
    generator.setTimeout(40000);

    //the data object to use for storing data related to building the
    //navigation mesh.
    IntermediateData data = new IntermediateData();
    generator.setIntermediateData(data);

    Mesh mesh = new Mesh();
    GeometryBatchFactory.mergeGeometries(findGeometries(app.getRootNode(),
            new LinkedList&lt;&gt;(), generator), mesh);

    //uncomment to show mesh
//        Geometry meshGeom = new Geometry("MeshGeometry");
//        meshGeom.setMesh(mesh);
//        showGeometry(meshGeom, ColorRGBA.Yellow);
//        saveNavMesh(meshGeom);

    Mesh optiMesh = generator.optimize(mesh);
    navMesh.loadFromMesh(optiMesh);

    Geometry geom = new Geometry(DataKey.NAVMESH);
    geom.setMesh(optiMesh);
    //display the mesh
    showGeometry(geom, ColorRGBA.Green);
    //save the navmesh to Scenes/NavMesh for loading
    exportNavMesh(geom, DataKey.NAVMESH);
    //save geom to rootNode if you wish
    saveNavMesh(geom);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>First, we create the <a href="https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavMeshGenerator.java">NavMeshGenerator</a> object and then use it to set the parameters for the NavMesh.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">generator = new NavMeshGenerator();
...
generator.setCellSize(.25f);
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>In our next step we create an IntermediateData object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//the data object to use for storing data related to building the
//navigation mesh.
IntermediateData data = new IntermediateData();
generator.setIntermediateData(data);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The IntermediateData object can be used to get information about the build process of the NavMesh such as build times. You query this object after building the NavMesh. If you don&#8217;t wish to see the data, set it to null.</p>
</div>
<div class="paragraph">
<p>At this point, you now have a <code>generator</code> object that you use to create the NavMesh with.</p>
</div>
<div class="paragraph">
<p>Included in the <a href="https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavMeshState.java">NavMeshState.java</a> file is the helper method <code>findGeometries</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//Gathers all geometries in supplied node into supplied List. Uses
//NavMeshGenerator to merge found Terrain meshes into one geometry prior to
//adding. Scales and sets translation of merged geometry.
private List&lt;Geometry&gt; findGeometries(Node node, List&lt;Geometry&gt; geoms,
          NavMeshGenerator generator)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is used to collect all geometries, attached to a node, into a List. If a child of the node is a Terrain instance (which can consist of many meshes), it will use the <code>generator</code> object to merge them into one mesh, then scale and set translation of the merged mesh prior to being added to the list. You then use GeometryBatchFactory to merge all the geometries in the list into a single <code>mesh</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mesh mesh = new Mesh();
GeometryBatchFactory.mergeGeometries(findGeometries(app.getRootNode(),
        new LinkedList&lt;&gt;(), generator), mesh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>After these methods execute, you have a single <code>mesh</code> object that is now ready to be optimized.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mesh optiMesh = generator.optimize(mesh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is where the parameters you set with the <code>generator</code> object are applied to the supplied <code>mesh</code>. The optimize method will return a new Mesh object that reflects your generator settings. Now is when any problems with your parameters will show themselves as either warnings or exceptions. You should keep changing the various parameters, one at a time and in small increments/decrements, until your <code>mesh</code> generates with no errors. See each parameter&#8217;s notes for suggestions on how to do so.</p>
</div>
<div class="paragraph">
<p>After the mesh generates, you need to link all of its cells together so it can be used as your <code>NavMesh</code> object. You do this by calling <code>loadFromMesh()</code> or <code>loadFromData()</code>, depending on your implementation, on your <code>optiMesh</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">navMesh.loadFromMesh(optiMesh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you look at the second contructor for the <code>NavMesh</code> class you will see this is all it does. You would use this constructor if you were loading a <code>Mesh</code> from a geometry that had already been optimized and saved into your <code>Assets</code> folder for example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public NavMesh(Mesh mesh) {
  loadFromMesh(mesh);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>NavMesh</code> object is now ready for use in your game, but you still need to create the geometry for it if you wish to save or view it. You do this the same as you would for any newly created mesh.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Geometry geom = new Geometry(DataKey.NAVMESH);
geom.setMesh(navMesh);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that you have your Mesh you should save it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//save the navmesh to Scenes/NavMesh for loading
exportNavMesh(geom, DataKey.NAVMESH);
//save geom to rootNode if you wish
saveNavMesh(geom);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this instance, the object is exported to the projects <code>Assets</code> folder so it can be loaded rather than generated every time the game starts. This is the preferred method. The <code>saveNavMesh()</code> method just attaches the geometry to the <code>rootNode</code>. How and where you choose to save depends on your implementation and personal preferences.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pathfinding"><a class="anchor" href="#pathfinding"></a>Pathfinding</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are many ways to implement the <code>NavMeshPathfinder</code> class of the jme3AI library. You can create a control, instantiate the <code>NavMeshPathFinder</code> class, and query the newly created object in a thread. You could use a single AppState to calculate all your paths. You could, as in this tutorial, extend the NavMeshPathFinder class in a custom control.</p>
</div>
<div class="paragraph">
<p>You also need a way to communicate <code>Vector3f</code> changes to the <code>NavMeshPathfinder</code>. This tutorial uses an ActionListener and Interface. You could just as easily create a public method in the control, and call it from the ActionListener, or store the <code>Vector3f</code> in <code>UserData</code> and look for changes from the control itself.</p>
</div>
<div class="paragraph">
<p>These are implementation decisions that are left up to you.</p>
</div>
<div class="sect2">
<h3 id="loading-the-navmesh"><a class="anchor" href="#loading-the-navmesh"></a>Loading the NavMesh</h3>
<div class="paragraph">
<p>In this tutorial example, the optimized mesh was exported as a geometry using the jMonkey binary format <code>.j3o</code>. Doing so means the loading of your <code>NavMeshes</code> is done the same way you load any model, by using the <code>AssetManager</code>. Once you load the <code>.j3o</code>, you grab its <code>Mesh</code> and create the <code>NavMesh</code> object to be passed to the <a href="https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavigationControl.java">NavigationControl</a> constructor. This tutorial uses a <a href="application_states.html#baseappstate#" class="page">BaseAppState</a> for model loading so access to the <code>Application</code> class is built in.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//load NavMesh geometry saved to assets folder
Geometry navGeom = (Geometry) getApplication().getAssetManager().
        loadModel("Scenes/NavMesh/NavMesh.j3o");
NavigationControl navControl = new NavigationControl(new NavMesh(
        navGeom.getMesh()), getApplication(), true)
charNode.addControl(navControl);
//NavigationControl implements Pickable Interface
picked = navControl;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This tutorial uses a custom control, <code>NavigationControl</code>, that extends the <code>NavMeshPathfinder</code> class. As this is a tutorial, some extra variables are used for dispalying the navigation path and are not needed. The constructor for <code>NavMeshPathfinder</code> requires just the the passing of the <code>NavMesh</code> object, which makes for a cleaner control.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public NavigationControl(NavMesh navMesh) {
  ...
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="communicating-with-navigationcontrol"><a class="anchor" href="#communicating-with-navigationcontrol"></a>Communicating with NavigationControl</h3>
<div class="paragraph">
<p>This tutorial makes use of the <a href="#../../jme3/beginner/hello_picking.adoc" class="page unresolved">Hello Picking</a> and <a href="mouse_picking.html#pick-a-target-using-the-mouse-pointer#" class="page">Mouse Picking</a> tutorials so you should already be familiar with this method for picking and how to add the <a href="#../../jme3/beginner/hello_input_system.adoc" class="page unresolved">input mappings</a> to your game. How you implement your ActionListener is up to you.</p>
</div>
<div class="listingblock">
<div class="title">PCState ActionListener</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    private class ClickedListener implements ActionListener {

        @Override
        public void onAction(String name, boolean isPressed, float tpf) {

            if (name.equals(ListenerKey.PICK) &amp;&amp; !isPressed) {
                CollisionResults results = new CollisionResults();
                Vector2f click2d = getInputManager().getCursorPosition().clone();
                Vector3f click3d = app.getCamera().getWorldCoordinates(click2d,
                        0f).clone();
                Vector3f dir = app.getCamera().getWorldCoordinates(
                        click2d, 1f).subtractLocal(click3d).normalizeLocal();
                Ray ray = new Ray(click3d, dir);
                app.getRootNode().collideWith(ray, results);

                for (int i = 0; i &lt; results.size(); i++) {
                    // For each hit, we know distance, impact point, name of geometry.
                    float dist = results.getCollision(i).getDistance();
                    Vector3f pt = results.getCollision(i).getContactPoint();
                    String hit = results.getCollision(i).getGeometry().getName();
                    System.out.println("* Collision #" + i);
                    System.out.println(
                            "  You shot " + hit
                            + " at " + pt
                            + ", " + dist + " wu away.");
                }

                if (results.size() &gt; 0) {
                    // The closest collision point is what was truly hit:
                    CollisionResult closest = results.getClosestCollision();
                    // Let's interact - we mark the hit with a red dot.
                    mark.setLocalTranslation(closest.getContactPoint());
                    app.getRootNode().attachChild(mark);
                    picked.setTarget(closest.getContactPoint());
                    System.out.println("  Closest Contact " + closest.
                            getContactPoint());
                } else {
                    // No hits? Then remove the red mark.
                    app.getRootNode().detachChild(mark);
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main line of interest here is,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">picked.setTarget(closest.getContactPoint());</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>picked</code> is the reference object used to communicate our <code>Vector3f</code> changes to the <code>NavigationControl</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//NavigationControl implements Pickable Interface
picked = navControl;</code></pre>
</div>
</div>
<div class="paragraph">
<p>At this point you have loaded your <code>NavMesh</code>, added the <code>NavigationControl</code> to your spatial, and instituted a method for communicating with the <code>NavMeshPathFinder</code>. Next we will delve into the details of the <code>NavigationControl</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="navigationcontrol"><a class="anchor" href="#navigationcontrol"></a>NavigationControl</h3>
<div class="paragraph">
<p>The <a href="https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/ai/NavigationControl.java">NavigationControl</a> is a <a href="custom_controls.html" class="page">custom control</a> that extends the <a href="https://github.com/MeFisto94/jme3-artificial-intelligence/blob/master/AI/src/com/jme3/ai/navmesh/NavMeshPathfinder.java">NavMeshPathFinder</a> class of the Jme3AI library and implements the <code>Pickable</code> interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class NavigationControl extends NavMeshPathfinder implements Control,
        JmeCloneable, Pickable {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/interfaces/Pickable.java">Pickable</a> interface is straightforward and its sole purpose in this implementation is to communicate changes made to the pick target.</p>
</div>
<div class="listingblock">
<div class="title">Pickable Interface implementation</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * @param target the target to set
 */
@Override
public void setTarget(Vector3f target) {
    this.target = target;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The heartbeat of the control lies in the pathfinding thread which makes calls to the <code>computePath()</code> method. Potentially long running tasks like this should always be ran from a thread. Below, is the constructor you would normally use to instantiate your control.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public NavigationControl(NavMesh navMesh) {
    super(navMesh); //sets the NavMesh for this control
    executor = Executors.newScheduledThreadPool(1);
    startPathFinder();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>First, you call <code>super(navMesh)</code> to set the <code>NavMesh</code> for the control, then setup your <code>ExecutorService</code> and start the pathfinding thread.</p>
</div>
<div class="paragraph">
<p>This is a custom thread implementation so it&#8217;s up to you to handle shutting it down. This is done in the controls <code>setSpatial()</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (spatial == null) {
    shutdownAndAwaitTermination(executor);
    ...
} else {
    ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Executor shutdown process</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//standard shutdown process for executor
private void shutdownAndAwaitTermination(ExecutorService pool) {
    pool.shutdown(); // Disable new tasks from being submitted
    try {
        // Wait a while for existing tasks to terminate
        if (!pool.awaitTermination(6, TimeUnit.SECONDS)) {
            pool.shutdownNow(); // Cancel currently executing tasks
            // Wait a while for tasks to respond to being cancelled
            if (!pool.awaitTermination(6, TimeUnit.SECONDS)) {
                LOG.log(Level.SEVERE, "Pool did not terminate {0}", pool);
            }
        }
    } catch (InterruptedException ie) {
        // (Re-)Cancel if current thread also interrupted
        pool.shutdownNow();
        // Preserve interrupt status
        Thread.currentThread().interrupt();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The easiest way to move a physics character is by using the <a href="walking_character.html#bettercharactercontrol#" class="page">BetterCharacterControl</a> class. In this implementation, this is done in the <a href="https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/controls/PCControl.java">PCControl</a> class by extending <code>BetterCharacterControl</code>. Since <code>BetterCharacterControl</code> is required to be present on the spatial for pathfinding, in the <code>setSpatial()</code> method, we throw an exception to let us know if it&#8217;s missing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (spatial == null) {
    ...
} else {
    pcControl = spatial.getControl(PCControl.class);
    if (pcControl == null) {
        throw new IllegalStateException(
                "Cannot add NavigationControl to spatial without PCControl!");
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pathfinding-thread"><a class="anchor" href="#pathfinding-thread"></a>Pathfinding Thread</h3>
<div class="listingblock">
<div class="title">NavigationControl pathfinding thread</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//Computes a path using the A* algorithm. Every 1/2 second checks target
//for processing. Path will remain untill a new path is generated.
private void startPathFinder() {
    executor.scheduleWithFixedDelay(() -&gt; {
        if (target != null) {
            clearPath();
            setWayPosition(null);
            pathfinding = true;
            //setPosition must be set before computePath is called.
            setPosition(spatial.getWorldTranslation());
            //warpInside(target) moves endpoint within the navMesh always.
            warpInside(target);
            System.out.println("Target " + target);
            boolean success;
            //comput the path
            success = computePath(target);
            System.out.println("SUCCESS = " + success);
            if (success) {
                //clear target if successful
                target = null;
                ...
            }
            pathfinding = false;
        }
    }, 0, 500, TimeUnit.MILLISECONDS);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>How you setup your pathfinding thread makes a significant difference.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">executor.scheduleWithFixedDelay(() -&gt; {
...
}, 0, 500, TimeUnit.MILLISECONDS);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This <code>ExecutorService</code> is set to start immediately (0) with a fixed delay of (500) milliseconds. This means the task has a fixed delay of 1/2 second between the end of an execution and the start of the next execution, i.e. it doesn&#8217;t take into account the actual duration of the task. If you were to use <code>scheduleAtFixedRate()</code>, you risk that the task doesn&#8217;t complete in the time allocated.</p>
</div>
<div class="paragraph">
<p>When you use the <code>BetterCharacterControl</code>, all that&#8217;s required to move the spatial is that you <code>setWalkDirection()</code> and the spatial will continuously move in that direction. The following code breakdown explains how the <code>NavigationControl</code> takes advantage of this.</p>
</div>
<div class="paragraph">
<p>It starts by having the pathfinding thread check a <code>target</code> variable for changes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (target != null) {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If it finds a target, it will compute a new path to that <code>target</code>, and if successful, update the <code>NavMeshPathfinder</code> path variable. The <code>update()</code> loop of the control continuously checks this path variable, and if its non-null, takes an appropriate action.</p>
</div>
<div class="paragraph">
<p>Before you compute the path you first clear the existing path, and set wayPosition to null.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (target != null) {
    clearPath();
    setWayPosition(null);
    pathfinding = true;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Doing this allows the player to select a new <code>target</code> at any time and immediately start moving along the new path. Otherwise, the character must finish the path they are on, then backtrack to the position the character was at when the <code>target</code> change was made, before then continuing on the new path.</p>
</div>
<div class="paragraph">
<p>Next, you must call <code>setPosition()</code> <strong>before</strong> calling the <code>computePath()</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (target != null) {
  ...
  setPosition(spatial.getWorldTranslation());
  ...
  //compute the path
  success = computePath(target);
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are some things you need to know about how a path is computed.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The first waypoint on any path is the one you set with <code>setPosition()</code>.</p>
</li>
<li>
<p>The last waypoint on any path is always the <code>target</code> Vector3f.</p>
</li>
<li>
<p>computePath() adds one waypoint to the cell <strong>nearest</strong> to the target only if you are not in the goalCell (the cell target is in), and if there is a cell between first and last waypoint, and if there is no direct line of sight.</p>
</li>
<li>
<p>If inside the goalCell when a new target is selected, computePath() will do a direct line of sight placement of target. This means there will only be two waypoints set, <code>setPosition()</code> and <code>target</code>.</p>
</li>
<li>
<p>If the <code>target</code> is outside the <code>NavMesh</code>, your endpoint will be as well.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To guarantee that <code>target</code> is always inside the <code>NavMesh</code>, call</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (target != null) {
    ...
    //warpInside(target) moves endpoint within the navMesh always.
    warpInside(target);
    ...
    //compute the path
    success = computePath(target);
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>before calling <code>computePath()</code> and the endpoint of the path will be moved to the closest cell to the <code>target</code> that&#8217;s inside the <code>NavMesh</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="character-movement"><a class="anchor" href="#character-movement"></a>Character Movement</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">NavigationControl update() loop</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Override
public void update(float tpf) {
    if (getWayPosition() != null) {
        Vector3f spatialPosition = spatial.getWorldTranslation();
        Vector2f aiPosition = new Vector2f(spatialPosition.x,
                spatialPosition.z);
        Vector2f waypoint2D = new Vector2f(getWayPosition().x,
                getWayPosition().z);
        float distance = aiPosition.distance(waypoint2D);
        //move char between waypoints untill waypoint reached then set null
        if (distance &gt; .25f) {
            Vector2f direction = waypoint2D.subtract(aiPosition);
            direction.mult(tpf);
            pcControl.setViewDirection(new Vector3f(direction.x, 0,
                    direction.y).normalize());
            pcControl.onAction(ListenerKey.MOVE_FORWARD, true, 1);
        } else {
            setWayPosition(null);
        }
    } else if (!isPathfinding() &amp;&amp; getNextWaypoint() != null
            &amp;&amp; !isAtGoalWaypoint()) {
        if (showPath) {
            showPath();
            showPath = false;
        }
        //advance to next waypoint
        goToNextWaypoint();
        setWayPosition(new Vector3f(getWaypointPosition()));

        //set spatial physical position
        if (getPositionType() == EnumPosition.POS_STANDING.position()) {
            setPositionType(EnumPosition.POS_RUNNING.position());
            stopFeetPlaying();
            stopTorsoPlaying();
        }
    } else {
        //waypoint null so stop moving and set spatials physical position
        if (getPositionType() == EnumPosition.POS_RUNNING.position()) {
            setPositionType(EnumPosition.POS_STANDING.position());
            stopFeetPlaying();
            stopTorsoPlaying();
        }
        pcControl.onAction(ListenerKey.MOVE_FORWARD, false, 1);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>computePath()</code> successfully computes a new path, the path variable of the <code>NavMeshPathfinder</code> will no longer be null. The update loop of the <code>NavigationControl</code> checks this path variable, every iteration that wayPosition is null, by calling the <code>getNextWaypoint()</code> method. If the path has another waypoint, it will advance to the next position in the path and set the <code>wayPosition</code> variable of the <code>NavigationControl</code> to that position.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">} else if (!isPathfinding() &amp;&amp; getNextWaypoint() != null
        &amp;&amp; !isAtGoalWaypoint()) {
    ...
    //advance to next waypoint
    goToNextWaypoint();
    setWayPosition(new Vector3f(getWaypointPosition()));
    ...
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Remember, the first waypoint in the path is always the spatials current position. This is why you always advance the position first.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the next iteration of the controls <code>update()</code> method, it sees that <code>wayPosition</code> is no longer null and calculates the distance from the spatials current position to the <code>wayPosition</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (getWayPosition() != null) {
    Vector3f spatialPosition = spatial.getWorldTranslation();
    Vector2f aiPosition = new Vector2f(spatialPosition.x,
            spatialPosition.z);
    Vector2f waypoint2D = new Vector2f(getWayPosition().x,
            getWayPosition().z);
    float distance = aiPosition.distance(waypoint2D);
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If it&#8217;s greater than the distance specified, it will <code>setViewDirection()</code> of the <code>PCControl</code> (which extends BetterCharacterControl) and then notify the <code>PCControl</code> that the spatial can move by calling the controls <code>onAction()</code> method directly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (getWayPosition() != null) {
    ...
    //move char between waypoints untill waypoint reached then set null
    if (distance &gt; .25f) {
        Vector2f direction = waypoint2D.subtract(aiPosition);
        direction.mult(tpf);
        pcControl.setViewDirection(new Vector3f(direction.x, 0,
                direction.y).normalize());
        pcControl.onAction(ListenerKey.MOVE_FORWARD, true, 1);
    } else {
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s up to the <code>NavigationControl</code> to determine when the character should stop moving. Each time the spatial reaches a point that is less than the specified distance, it sets the wayPosition to null.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (distance &gt; .25f) {
    ...
} else {
    setWayPosition(null);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the path position has not yet reached the end, it will once again be advance to the next waypoint in the path and update the wayPosition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">} else if (!isPathfinding() &amp;&amp; getNextWaypoint() != null
        &amp;&amp; !isAtGoalWaypoint()) {
    ...
    //advance to next waypoint
    goToNextWaypoint();
    setWayPosition(new Vector3f(getWaypointPosition()));
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the last waypoint is reached, the <code>NavigationControl</code> notifies the <code>PCControl</code> that the spatial can no longer move.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">} else {
    ...
    pcControl.onAction(ListenerKey.MOVE_FORWARD, false, 1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/jMonkeyEngine/doc-examples/blob/master/src/com/jme3/examples/jme3ai/controls/PCControl.java">PCControl</a> class handles the actual movement of the spatial in its <code>update()</code> loop. It does this by checking the <code>forward</code> variable every iteration. This variable is set when you call the <code>onAction()</code> method from the <code>NavigationControl</code> update loop.</p>
</div>
<div class="listingblock">
<div class="title">PCControl ActionListener</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Override
public void onAction(String name, boolean isPressed, float tpf) {
    if (name.equals(ListenerKey.MOVE_FORWARD)) {
        forward = isPressed;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PCControl update() loop</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Override
public void update(float tpf) {
    super.update(tpf);
    this.moveSpeed = 0;
    walkDirection.set(0, 0, 0);
    if (forward) {
        Vector3f modelForwardDir = spatial.getWorldRotation().mult(Vector3f.UNIT_Z);
        position = getPositionType();
        for (EnumPosition pos : EnumPosition.values()) {
            if (pos.position() == position) {
                switch (pos) {
                    case POS_RUNNING:
                        moveSpeed = EnumPosition.POS_RUNNING.speed();
                        break;
                    default:
                        moveSpeed = 0f;
                        break;
                }
            }
        }
        walkDirection.addLocal(modelForwardDir.mult(moveSpeed));
    }
    setWalkDirection(walkDirection);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PCControl</code> will then set the walk direction, based off spatials world rotation, and set the speed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion"><a class="anchor" href="#conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The intent of this tutorial was to give you a general breakdown of how the Jme3AI navigation system works as well as demonstrate how flexible its implementation is. All the code in this tutorial is free for your use and can be found in the <a href="https://github.com/jMonkeyEngine/doc-examples">jme3 documentation repository</a>. The implementations design is such that you can easily change each of the parameters and then visually see how they affect the NavMesh. If you have questions or suggestions on improving this tutorial you can do so in the <a href="https://hub.jmonkeyengine.org/">jMonkeyEngine forum</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="other-ai-options"><a class="anchor" href="#other-ai-options"></a>Other AI Options</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are other jME3 specific options available you can read about in the wiki under the topic <a href="https://wiki.jmonkeyengine.org/docs/jme3.html#artificial-intelligence-ai">Artificial Intelligence (AI)</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="further-reading"><a class="anchor" href="#further-reading"></a>Further Reading</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="../../_attachments/Astar.pdf">A* path-finding for Beginners</a> by Patrick Lester</p>
</li>
<li>
<p><a href="http://natureofcode.com/book/">The Nature of Code</a> by Daniel Shiffman</p>
</li>
<li>
<p><a href="http://www.red3d.com/cwr/steer/gdc99/">Steering Behaviors For Autonomous Characters</a> by Craig W. Reynolds</p>
</li>
<li>
<p><a href="http://www.critterai.org/projects/nmgen_study/">Study: Navigation Mesh Generation Java</a> by Stephen Pratt</p>
</li>
</ul>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Path-finding means computing the shortest route between two points. Usually mazes.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. Path-following is taking a path that already exists and then following that path.
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>Copyright 2020 jMonkeyEngine Wiki Contributors. Licensed BSD-3.</p>
</footer>
<script src="../../../_/js/vendor/docsearch.min.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
var search = docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#search-input',
  autocompleteOptions: { hint: false, keyboardShortcuts: ['s'] },
  algoliaOptions: { hitsPerPage: 10 }
}).autocomplete
search.on('autocomplete:closed', function () { search.autocomplete.setVal() })
function focusSearchInput () { document.querySelector('#search-input').focus() }
if (document.querySelector('.home-link.is-current')) window.addEventListener('load', focusSearchInput)
</script>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
