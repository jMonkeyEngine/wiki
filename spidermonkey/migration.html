<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><meta name="keywords" content="documentation, network"><title>SpiderMonkey: Migrating to the Current API</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/jMonkeyEngine/wiki/edit/master/src/docs/asciidoc/spidermonkey/migration.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/jMonkeyEngine/wiki/new/master/src/docs/asciidoc/spidermonkey/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>SpiderMonkey: Migrating to the Current API</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version ,</span> <span id="revdate">2016/03/17 20:48</span></div><div id="toc" class="toc2"><div id="toctitle">Table of Contents</div><ul class="sectlevel1"><li><a href="#overview">Overview</a></li><li><a href="#what-s-gone">What&#8217;s Gone?</a></li><li><a href="#migration">Migration</a><ul class="sectlevel2"><li><a href="#package-class-imports">Package/Class Imports</a></li><li><a href="#client-and-messagelistener">Client and MessageListener</a></li><li><a href="#message-getclient-and-message-getconnection">Message.getClient() and Message.getConnection()</a></li><li><a href="#client-id-and-player-id">Client ID and Player ID</a></li><li><a href="#com-jme3-network-event-connectionlistener">com.jme3.network.event.ConnectionListener</a></li></ul></li><li><a href="#why-am-i-doing-this-again">Why am I doing this again?</a></li></ul></div></div><div id="content"><div id="preamble"><div class="sectionbody"><div class="admonitionblock warning"><table><tr><td class="icon"><i class="fa icon-warning" title="Warning"></i></td><td class="content"><div class="paragraph"><p>This article covers how to move away from an older, deprecated <abbr title="Application Programming Interface">API</abbr>! If you just start with JME3 networking, see <a href="../jme3/advanced/networking.html">networking</a> for current documentation.</p></div></td></tr></table></div>
<div class="paragraph"><p>This document provides an overview of the new versus  the old SpiderMonkey <abbr title="Application Programming Interface">API</abbr>, and a path for migrating from the old, now deprecated, <abbr title="Application Programming Interface">API</abbr> to the newer version.  Much has changed.
The <a href="../spidermonkey.html">original SpiderMonkey</a> implementation was a good concept and a clever implementation but suffered under the weight of rapid patches and some creeping design deficit.  In the end, there were enough small problems, long-term maintenance issues, and limitations that a newer design was warranted.
Some things will be very similar but others have changed very much. Hopefully for the better.</p></div></div></div>
<div class="sect1"><h2 id="overview">Overview</h2><div class="sectionbody"><div class="paragraph"><p>Most of the new SpiderMonkey <abbr title="Application Programming Interface">API</abbr> now exists as a set of interfaces and helper classes in the 'com.jme3.network' package.  For most users, this package and the 'message' package will be all they need to worry about.  The 'base' and 'kernel' packages only come into play when implementing custom network transports or alternate client/server protocols (<em>which are now possible</em>).
Clients and Servers can be created from the factory methods on the Network helper class.  Once a Server instance is created and started, it can accept remote connections from Clients.  The Client objects represent the client-side of a client→server connection.  Within the Server, these are HostedConnections.  This is a distinct change from the old <abbr title="Application Programming Interface">API</abbr>.</p></div>
<table class="tableblock frame-all grid-all spread"><colgroup><col style="width: 33.3333%;"><col style="width: 33.3333%;"><col style="width: 33.3334%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Client</th><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Server</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.Client</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>←→</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.HostedConnection</p></div></div></td></tr></tbody></table>
<div class="paragraph"><p>HostedConnections can hold application defined client-specific session attributes that the server-side listeners and services can use to track player information, etc..
MessageListeners can be registered with either the Client or the Server to be notified when new messages arrive.  As before, these listeners can be registered to be notified about only specific
types of messages.
ClientStateListeners can be registered with a Client to detect changes in connection state.
ConnectionListeners can be registered with a Server to be notified about HostedConnection arrivals and removals.</p></div></div></div>
<div class="sect1"><h2 id="what-s-gone">What&#8217;s Gone?</h2><div class="sectionbody"><div class="paragraph"><p>All of 'connection', 'events', 'queue', 'service', 'streaming', and 'sync' are now deprecated.  The 'service', 'streaming', and 'sync' packages were too difficult to easily port to the new <abbr title="Application Programming Interface">API</abbr> and would have required additional code review for thread-related issues.  Since the service manager model has <em>not</em> been ported and will likely live on in a different way, it was better to let these go until better solutions evolve.  For example, streaming is probably better done more tightly integrated with the core <abbr title="Application Programming Interface">API</abbr> and as actual java.io streams.</p></div></div></div>
<div class="sect2"><h3 id="migration">Migration</h3><div class="sect2"><h3 id="package-class-imports">Package/Class Imports</h3><div class="paragraph"><p>As a first pass, use the following table for conversion and then see specific class notes.</p></div>
<table class="tableblock frame-all grid-all spread"><colgroup><col style="width: 50%;"><col style="width: 50%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Old Class</th><th class="tableblock halign-left valign-top">New Class</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.connection.Client</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.Client or com.jme3.network.HostedConnection</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.connection.Server</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.Server</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.event.MessageListener</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.MessageListener</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.event.ConnectionListener</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.ClientStateListener or com.jme3.network.ConnectionListener</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.event.MessageAdapter</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>no equivalent class, implement MessageListener directly</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.event.ConnectionAdapter</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>no equivalent class, implement ClientStateListener or ConnectionListener directly</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>com.jme3.network.message.Message</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>if used as a reference and not a superclass, com.jme3.network.Message.  The base class stays the same for message subclasses.</p></div></div></td></tr></tbody></table>
<div class="paragraph"><p>Doing all of those changes will certainly break your build… so now let&#8217;s fix it.</p></div></div>
<div class="sect2"><h3 id="client-and-messagelistener">Client and MessageListener</h3><div class="paragraph"><p>This class is the hardest migration to perform.  Do not get discouraged.
The old version used com.jme3.network.connection.Client for both client side and server side.  So, depending on context, these references will either change to com.jme3.network.Client or com.jme3.network.HostedConnection.  In the case where calling code is not client or server specific, then there is also the common com.jme3.network.MessageConnection interface.
In general, the actual client changes are of one of the following to types:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">  Client client = <span class="keyword">new</span> Client( host, port );
  ...becomes...
  Client client = Network.connectToServer( host, port );</code></pre></div></div>
<div class="paragraph"><p>In the delayed connection case:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">  Client client = <span class="keyword">new</span> Client();
  ...
  client.connect( host, port );
  ...becomes...
  NetworkClient client = Network.createClient();
  ...
  client.connectToServer( host, port );</code></pre></div></div>
<div class="paragraph"><p>NetworkClient is a Client.  The rest of your code can just refer to Client.
Those are the easy changes.  The trickier ones are related to the MessageListeners.</p></div>
<div class="sect3"><h4 id="messagelistener">MessageListener</h4><div class="paragraph"><p>By now you&#8217;ve figured out that all of your MessageListeners are broken because the new method signature is different.  The source of a message is no longer stored with the message and is instead provided to the MessageListener.
Depending on whether your MessageListener is being added to the Client or the Server, it will need to refer to either com.jme3.network.Client or com.jme3.network.HostedConnection in its messageReceived(), respectively.  The MessageListener interface is generically typed to help make sure the right listener goes where it&#8217;s supposed to and so the listener implementations don&#8217;t have to cast all the time.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// An example client-specific listener</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyClientListener</span> <span class="directive">implements</span> MessageListener&lt;Client&gt; {
    <span class="directive">public</span> <span class="type">void</span> messageReceived( Client source, Message m ) {
       ...do stuff...
    }
}
<span class="comment">// And example server-specific listener</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyServerListener</span> <span class="directive">implements</span> MessageListener&lt;HostedConnection&gt; {
    <span class="directive">public</span> <span class="type">void</span> messageReceived( HostedConnection source, Message m ) {
        ...do stuff...
    }
}
<span class="comment">// A client or server listener</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyGenericListener</span> <span class="directive">implements</span> MessageListener&lt;MessageConnection&gt; {
    <span class="directive">public</span> <span class="type">void</span> messageReceived( MessageConnection source, Message m ) {
        ... do limited stuff....
    }
}</code></pre></div></div>
<div class="paragraph"><p>Your listeners will fall into one of those three categories.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="paragraph"><p>Several of the old MessageListener&#8217;s methods have gone away.  The object-based methods didn&#8217;t fit with the new <abbr title="Application Programming Interface">API</abbr> and messageSent() seemed of little utility.  It could be resurrected if there is demand.</p></div></td></tr></table></div></div>
<div class="sect3"><h4 id="client-method-changes">Client method changes</h4><div class="paragraph"><p>Some of the methods on the old Client class have changed or been removed.  Here is a basic summary:</p></div>
<table class="tableblock frame-all grid-all spread"><colgroup><col style="width: 50%;"><col style="width: 50%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Old Method</th><th class="tableblock halign-left valign-top">New Method</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Client.disconnect()</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Client.close() or HostedConnection.close(reason)</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Client.kick(reason)</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>HostedConnection.close(reason)</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Client.getClientID()</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Client.getId() or HostedConnection.getId()</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Client.get/setPlayerID()</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>no equivalent</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Client.get/setLabel()</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>no equivalent</p></div></div></td></tr></tbody></table></div>
<div class="sect3"><h4 id="no-ioexceptions">No IOExceptions</h4><div class="paragraph"><p>After you&#8217;ve done all of that, the compiler will be complaining about the fact that send(), broadcast(), etc. no longer throw IOException.  So remove all of those try/catch blocks.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="paragraph"><p>The truth is that even in the old <abbr title="Application Programming Interface">API</abbr>, expecting a real IOException from these methods was unreasonable because often times the message was queued and actually sent later by a separate thread.  The new <abbr title="Application Programming Interface">API</abbr> assumes that all underlying transports will operate this way and so forgoes the artificial annoyance or sense of security provided by these 'throws' clauses.  It also simplifies the calling code a great deal.</p></div></td></tr></table></div>
<div class="paragraph"><p>Only <abbr title="Application Programming Interface">API</abbr> methods that actually perform direct IO (such as the Network.connectToServer() and NetworkClient.connectToServer() methods) will ever be declared to throw IOException.</p></div></div></div>
<div class="sect2"><h3 id="message-getclient-and-message-getconnection">Message.getClient() and Message.getConnection()</h3><div class="paragraph"><p>This is important enough to deserve its own sub-heading because your code <strong>will</strong> break if you use these as they now return null.  Any reason for calling them is now provided directly to the MessageListener in the form of the source Client or source HostedConnection.</p></div></div>
<div class="sect2"><h3 id="client-id-and-player-id">Client ID and Player ID</h3><div class="paragraph"><p>The ID of the Client and HostedConnection are now the same at both ends of a connection and the ID is given out authoritatively by the hosting Server.  This removes some of the inconsistency on when to use the old player ID and when to use the old client ID as the new client ID serves both purposes.  This leaves the game to be able to define its own player ID based on whatever user criteria it wants.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="paragraph"><p>Many of the reasons for accessing the client ID on the server can now be taken care of using the session attributes on HostedConnection.  It seems like a common use-case for these IDs was to look-up player/client-specific information in a java.util.Map.  This information can now be set directly on the HostedConnection.</p></div></td></tr></table></div></div>
<div class="sect2"><h3 id="com-jme3-network-event-connectionlistener">com.jme3.network.event.ConnectionListener</h3><div class="paragraph"><p>Along with the shift from not using the same object at both ends of the client connection was a shift in the interfaces that are notified about those ends.
On the client, there is now com.jme3.network.ClientStateListener which is notified when the client fully connects to the server (including any internal handshaking) and when the client is disconnected.
On the server, com.jme3.network.ConnectionListener will be notified whenever new HostedConnections are added or removed.  This listener isn&#8217;t notified until the connection is fully setup (including any internal handshaking).</p></div>
<table class="tableblock frame-all grid-all spread"><colgroup><col style="width: 50%;"><col style="width: 50%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Old Method</th><th class="tableblock halign-left valign-top">New Method</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>clientConnected(Client)</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>connectionAdded(Server,HostedConnection)</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>clientDisconnected(Client)</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>connectionRemoved(Server,HostedConnection)</p></div></div></td></tr></tbody></table></div></div>
<div class="sect1"><h2 id="why-am-i-doing-this-again">Why am I doing this again?</h2><div class="sectionbody"><div class="paragraph"><p>As you&#8217;ve seen above, there are quite a few changes necessary to migrate to the new <abbr title="Application Programming Interface">API</abbr>.  You might be asking yourself if it&#8217;s worth the trouble.
The bottom line is that the old architecture had threading and stability issues that just couldn&#8217;t be fixed in any reasonable way.  Some were minor, others kind of severe… and they combined to make trouble.  If you&#8217;ve ever wondered why sometimes your clients connect and then the network connection hangs or stops sending data.  Or if you&#8217;ve ever wondered why UDP/unreliable messages get corrupted or somehow won&#8217;t deserialize properly then you&#8217;ve run into some of these issues.
Moreover, the lack of thread safety meant that user code sometimes had to do some strange and/or complicated work-arounds.  The goal should be that the <abbr title="Application Programming Interface">API</abbr> should just work like it looks like it will with a minimum of hassle.
The new architecture is built from the ground up for threading stability and for a clean separation between the public <abbr title="Application Programming Interface">API</abbr>, the message passing layer, and the underlying network transport implementations.  You should be able to throw all kinds of stuff at it that would make the old system fall over and it should just hum along.
There will certainly be some growing pains as we work the kinks out of the new system but it is already much more stable in even the most basic of stress tests.</p></div></div></div></div><div id="footer"><div id="footer-text">Version <br>Last updated 2017-11-14 05:28:25 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>