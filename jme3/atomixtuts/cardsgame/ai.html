<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><title>ai</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/jMonkeyEngine/wiki/edit/master/src/docs/asciidoc/jme3/atomixtuts/cardsgame/ai.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/jMonkeyEngine/wiki/new/master/src/docs/asciidoc/jme3/atomixtuts/cardsgame/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>ai</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version ,</span> <span id="revdate">2016/03/17 20:48</span></div><div id="toc" class="toc2"><div id="toctitle">Table of Contents</div><ul class="sectlevel1"><li><a href="#cardsgame-ai">CardsGame: AI</a></li><li><a href="#a-tattic-and-stragegies">A – Tattic and stragegies</a><ul class="sectlevel2"><li><a href="#summon-cards-main-phase-1-2">Summon Cards (Main phase 1&amp;2):</a></li><li><a href="#use-support-cards-every-action-phases">Use support Cards (every action phases):</a></li><li><a href="#decide-what-to-do">Decide what to do:</a></li></ul></li><li><a href="#b-ai-techs">B-AI Techs</a><ul class="sectlevel2"><li><a href="#decision-behavior-tree">Decision/Behavior Tree</a></li><li><a href="#finite-state-machine">Finite State Machine</a></li><li><a href="#minimax">MiniMax</a></li><li><a href="#fuzzylogic">FuzzyLogic</a></li><li><a href="#casebase">CaseBase</a></li></ul></li><li><a href="#c-atomai-usages">C-AtomAI usages</a></li><li><a href="#d-implementation">D-Implementation</a></li></ul></div></div><div id="content"><div class="sect1"><h2 id="cardsgame-ai">CardsGame: AI</h2><div class="sectionbody"><div class="paragraph"><p>Now back to the basic, in a general card game, gameplay consist of fews ideas:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Which card to choose</p></li><li><p>Which state of that card to choose</p></li></ol></div>
<div class="paragraph"><p>In a magic card game, two opponents including AI should concern a few more and how to answer these question to defeat the other:</p></div>
<div class="ulist"><ul><li><p>Which magic card support/destroy which card</p></li><li><p>How to get Best health point and best damage</p></li></ul></div></div></div>
<div class="sect2"><h3 id="a-tattic-and-stragegies">A – Tattic and stragegies</h3><div class="paragraph"><p>Now I kind of don’t want to write much about AI in the first tutorial but let’s go, it wont take too long.</p></div>
<div class="paragraph"><p>In this game, the AI should have appropriate stragegies from Phase to Phase, even though, we should have a global stragegy for each round. Here are “naive” stragegies of the magic card AI:</p></div>
<div class="sect2"><h3 id="summon-cards-main-phase-1-2">Summon Cards (Main phase 1&amp;2):</h3><div class="paragraph"><p>In the MainPhase, if you can summon, that mean there is card for you to have a valid summon. Wisely choose one option:</p></div>
<div class="sect3"><h4 id="stragegy-1-choose-the-biggest-attack-defend-card">- STRAGEGY 1) Choose the biggest attack/defend card.</h4><div class="paragraph"><p>When you don’t have enough appropriate tribute cards to summon a “many stars” Card</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Just summon the biggest attack\defend card you have.</p></li><li><p>To decide to summon (attack||defend), check what cards are in the field at the moment and compare your cards to your opponent cards, if the result is :</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>“GoodToAttack” – choose Biggest Attack – Attack State</p></li><li><p>“ShouldDefend” – choose Biggest Defend – Defend state</p></li></ol></div></li><li><p>summon it, and to the next Phase</p></li></ol></div></div>
<div class="sect3"><h4 id="stragegy-2-choose-fews-smallest-card-to-tribute-and-summon-a-biggest-one">- STRAGEGY 2) Choose fews smallest card to tribute and summon a biggest one.</h4><div class="paragraph"><p>When you HAVE enough appropriate tribute cards to summon a “many stars” Card (always with big attack/defend points and have effects)</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Choose the “biggest” and “most many stars” card.</p></li><li><p>Choose the “smallest” cards enough to tribute to summon this card.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>If you can not even summon anything, have to Pass (by the rule).</p></li></ol></div></li><li><p>Futher, if there is no card in your ground mark the Brain with “Dangerous situation” and Pass.</p></li></ol></div>
<div class="paragraph"><p>——</p></div></div></div>
<div class="sect2"><h3 id="use-support-cards-every-action-phases">Use support Cards (every action phases):</h3><div class="paragraph"><p>In every action phase, except for DrawPhase and Endphase, you can use support card like MagicCard, TrapCard…etc. We can design a function to evaluate thoose card by how good is going to be when called in the game, but for the time being, we use such simplest tragagy:
'''</p></div>
<div class="sect3"><h4 id="stragegy-3-use-all-the-support-cards-in-one-turn">STRAGEGY 3) Use all the support cards in one turn</h4><div class="paragraph"><p>That mean you are very hungry for the final win. It’s not always intelligent to do so in the POV of a professional duelist but hey… Ok. Now we want to pull all out support cards in one turn.
'''</p></div></div>
<div class="sect3"><h4 id="stragegy-4-category-cards-in-the-game">STRAGEGY 4) Category cards in the game</h4><div class="paragraph"><p>You should devide the support card and its effect to type and handle it by type, that’s the naive way but appropriate for DecisionTree technique we used here.
'''</p></div>
<div class="paragraph"><p>Q&amp;A</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Q: How many type of support card are there?</p></li><li><p>A: Trap card can flip whenever opponent take action like summon or attack. Magic card can do almost every effect from increase healpoint to destroy everything, change the field</p></li><li><p>Q: How many type this naive AI know how to use?</p></li><li><p>A: Many type of support card and effect are there in the real game but the AI use a “DecisionTree” technique just use a few which you know exactly what it do. For more complicated intelligent, we have to use complicated AI model like Neutral network or Genetic Algorimth..:</p><div class="ulist"><ul><li><p>o) Support Point Card: Card that increase/decrease the demon cards point.</p></li><li><p>o) Heal Card: Card that increase/decrease the opponents point directly.</p></li><li><p>o) Special Summon Card: Card that can bring demon card to the field in special way.</p></li><li><p>o) Destroy/Clean Card: Card that destroy demons or other support card</p></li><li><p>o) State Constraint Card: Card that lock or unlock the Limit of the game, like noActtack, noDefend..</p></li></ul></div></li></ol></div>
<div class="paragraph"><p>——</p></div></div>
<div class="sect3"><h4 id="stragegy-5-bigger-biggest-smallest-smaller">STRAGEGY 5) Bigger biggest – Smallest smaller</h4><div class="ulist"><ul><li><p>Q: Which Support Point Card support to which demon?</p></li><li><p>A: You want to combine a biggest possible Card. So all biggest support card to the biggest demon. In oposite, you want to decrease all the demon of opponent on the field to the point that you can destroy it by attack or can not attack you anymore. So you just try to find the way to decrease those attack point to</p><div class="ulist"><ul><li><p>o) the smallest defend point of your defend demon if you have any defend demon</p></li><li><p>o) or smallest attack point if you only have attack demon</p></li><li><p>o) or 0 if you have no demon</p></li></ul></div></li></ul></div>
<div class="paragraph"><p>We can have sotisphicated way to distribute thoose support point but just do it as simple as possible.
'''</p></div></div></div>
<div class="sect2"><h3 id="decide-what-to-do">Decide what to do:</h3><div class="sect3"><h4 id="stragegy-6-attack-who-and-how-decide-to-attack-or-defend">STRAGEGY 6) Attack who and how? Decide to attack or defend</h4><div class="paragraph"><p>Image you have a few demons in the field to attack your opponent.</p></div>
<div class="sect4"><h5 id="step1-first-glance-calculation">Step1, first glance calculation:</h5><div class="paragraph"><p>There is 3 situation here:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>All your demon are better than your opponent’s current avaiable cards, so you will not lose any health point in the next turn, even if your opponent attack back. It’s called Dominance in game theory</p></li><li><p>In our game, this situation call “GoodToAttack”</p></li><li><p>You have a few better and a few worse, you want to attack. – This situation call “Average” and need futher calulation.</p></li><li><p>You can not attack at all, or lost points. So you should switch to defend. – This situation call “ShouldDefend”. (Not to mention: Affaid of trap card will flip when you take action?)</p></li><li><p>In fact, 3 above situations can be calculated by dertemine “forecast” result health point of two opponents.</p></li></ol></div></div>
<div class="sect4"><h5 id="step2-further-calculation">Step2, further calculation:</h5><div class="paragraph"><p>Apply the attack of all your the demons to each of your opponent demons and calculate the result points of both, call it a case. Best case is you win directly, less good case is you cause damage a lot, worse case, you should not attack cause you lose or lost points, it’s a bad idea.</p></div></div>
<div class="sect4"><h5 id="step3-apply">Step3, Apply:</h5><div class="paragraph"><p>After finish calculation, you apply the whole case in the current turn.
'''</p></div></div></div>
<div class="sect3"><h4 id="stragegy-7-dangerous-prevent-attack-goodtoattack-prevent-deffend">STRAGEGY 7) Dangerous – Prevent attack | GoodToAttack – Prevent deffend</h4><div class="paragraph"><p>The state constraints are very powerful stragegy when you can use it.
If you in Dangerous situation, which your AI brain mark. You can prevent your opponent not to attack in a few rounds or forever. In opposite, you can prevent your opponent to take defend by the opposite constraint.
If you only have the magic card to constraint one card, use it with the biggest or smallest card possible so your benifit is maximum!</p></div>
<div class="paragraph"><p>The usage of Heal Card ,Destroy/Clean Card,Special Summon are trivial and pretty obvious by combining the previous stragegy so I ommited this part! :p
'''</p></div></div></div></div>
<div class="sect2"><h3 id="b-ai-techs">B-AI Techs</h3><div class="paragraph"><p>As the result of making a sotiphicated AI, AI common techniques are used in mixed form, specific with the native of languages and tied to the game or the game engine.</p></div>
<div class="paragraph"><p>But it&#8217;s a good idea to clarify some parts of them to help you see the design more clearly and recoginize the pattern for your futher developing.</p></div>
<div class="paragraph"><p>It&#8217;s also worth to mention some patterns that already used in JME3 here and there: like State pattern, .</p></div>
<div class="sect2"><h3 id="decision-behavior-tree">Decision/Behavior Tree</h3><div class="paragraph"><p>Decision/Behavior Tree</p></div>
<div class="paragraph"><p>From wikipedia</p></div>
<div class="paragraph"><p>In this game, Decision/Behavior Tree is not metioned as a implementation of Data base Decision/Behavior Tree like common in AI playground, but a structure to define actions and behaviours, that&#8217;s a tree. Whatever your tree building techniques is, the Tree than decide very separation situations in a nested form.</p></div>
<div class="paragraph"><p>That&#8217;s why Decision Tree is pretty straight forward for almost programming language (via built in branching controls, such as : switch or if/else ).</p></div>
<div class="paragraph"><p>In this game, Decision Tree help in organize situations in each phases.</p></div></div>
<div class="sect2"><h3 id="finite-state-machine">Finite State Machine</h3><div class="paragraph"><p>In this game, Finite State Machine help to implement simple Card Character AI.</p></div></div>
<div class="sect2"><h3 id="minimax">MiniMax</h3><div class="paragraph"><p>In the previous section, we talked about “Forecast what will happen in a few next rounds”, if you know the result, you can definitely choose a most appropriate path. There is a related problem in the field of AI Tactic, called Minimax. The basic idea of minimax is .</p></div>
<div class="paragraph"><p>From wikipedia</p></div>
<div class="paragraph"><p>In this game, MiniMaxing is a little bit different from what you see in a normal Board/Chess game for example. MiniMaxing here help to evaluate the DesisionTree in a short term (mean short in time and light in processing space..)</p></div></div>
<div class="sect2"><h3 id="fuzzylogic">FuzzyLogic</h3><div class="paragraph"><p>FuzzyLogic  is</p></div>
<div class="paragraph"><p><a href="http://en.wikipedia.org/wiki/Fuzzy_logic">http://en.wikipedia.org/wiki/Fuzzy_logic</a></p></div>
<div class="paragraph"><p>In this game, FuzzyLogic is applied to extract the features and the situation from the game state and help decide what situation its it. Its upper layer is Case base (formed by more exact , accurate AI situation model)</p></div></div>
<div class="sect2"><h3 id="casebase">CaseBase</h3></div></div>
<div class="sect1"><h2 id="c-atomai-usages">C-AtomAI usages</h2><div class="sectionbody"></div></div>
<div class="sect1"><h2 id="d-implementation">D-Implementation</h2><div class="sectionbody"><div class="paragraph"><p>In above sections, we already declare a few rules which can have us to filter out which card are in hand, which card are in grave, ground, magic… etc. Later we will use them as ultilites in the AI.</p></div>
<div class="paragraph"><p>The first try to implement the AI</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">magiccard.gameplay.ai</span>

<span class="namespace">import</span> <span class="namespace">magiccard</span>.*
<span class="namespace">import</span> <span class="namespace">magiccard.gameplay</span>.*
<span class="namespace">import</span> <span class="namespace">static</span> <span class="namespace">magiccard.gameplay.TurnPhase.TurnPhaseType</span>.*
<span class="comment">/**
 * This class is the AI for playing YugiOh Magic Card game.
 * The main technique used is DecisionTree &amp; NeutralNetwork to decide actions
 */</span>
<span class="namespace">public</span> <span class="namespace">class</span> <span class="namespace">CardPlayerAI</span> {
    <span class="namespace">enum</span> <span class="namespace">AILevel</span> {<span class="namespace">Starter</span>,<span class="namespace">Normal</span>,<span class="namespace">HardCore</span>,<span class="namespace">Duelist</span>,<span class="namespace">Best</span>;
        <span class="type">int</span> deep;
    }
    AILevel level;
    CardGamePlay gamePlay;
    CardPlayer player;
    <span class="type">enum</span> StragegySituation {GoodToAttack,ShouldDefend,Unknown,Dangeous}
    StragegySituation situation= StragegySituation.Unknown;
    def memories = [:]
    <span class="comment">// The list of special card (id) that will have higher priority at any time</span>
    def listOfSpecialCards = <span class="type">[]</span>

    <span class="comment">/**
     *AI sepecific params
     **/</span>
    <span class="type">int</span> maxTime = <span class="integer">5000</span>
    <span class="type">int</span> maxSteps = <span class="integer">500</span>
    <span class="type">int</span> maxBranch = <span class="integer">50</span>
    <span class="type">int</span> maxGuess = <span class="integer">5</span>

    <span class="type">int</span> randomness = <span class="integer">30</span>

    <span class="comment">// save delayed action</span>
    def actions
    <span class="directive">public</span> CardPlayerAI(CardGamePlay gamePlay){
        <span class="local-variable">this</span>.gamePlay = gamePlay;
        <span class="local-variable">this</span>.actions = <span class="type">[]</span>
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> toString(){
        <span class="keyword">return</span> <span class="error">“</span>AI level : <span class="error">“</span>+<span class="local-variable">this</span>.level.toString() + <span class="error">”</span> status :<span class="error">”</span> + <span class="local-variable">this</span>.situation.toString()
    }
    <span class="directive">public</span> <span class="type">int</span> think(){
        <span class="type">int</span> startTime = <span class="predefined-type">System</span>.currentTimeMillis()
        <span class="keyword">if</span> (gamePlay.currentTurn.currentPhase.type == MainPhase){
            <span class="comment">// try to summon</span>
            <span class="keyword">if</span> (!gamePlay.currentTurn.currentPhase.monsterSummoned){
                def summonableCards = player.hand.findAll{card-&gt; canSummon(card)==<span class="predefined-constant">true</span>};
                <span class="keyword">if</span> (!summonableCards.isEmpty()){
                    def bestCard = summonableCards.max{card-&gt; card.attack}
                    actions&lt;
            delayedAct()
        }

        actions.clear();
    }
    <span class="comment">//self action</span>

    <span class="type">void</span> summon(Card card){
        gamePlay.notifyMoveCard(card,<span class="error">”</span>enableHover<span class="error">”</span>)
        gamePlay.fromHandToGround(card);
        gamePlay.currentTurn.currentPhase.monsterSummoned = <span class="predefined-constant">true</span>;
    }
    <span class="comment">/**
     * MINIMAX SUPPORT
     * See the game as the minimum forecastable loss problem and calculate the case
     * In fact, you can use minimax as a base heristic case and then extend
     */</span>

    <span class="comment">/**
     * CASE BASE SUPPORT
     * Not for a naive approach anymore.
     * In fact, you can build a heristic case and calculate the result in a few next round to see if the value you gain (win) or lost is sastified
     */</span>
    def tryCase(Case aCase){
        <span class="keyword">return</span> result;
    }
    def askForSelect(type,inCardList,info,condition){

    }
    <span class="directive">public</span> Case findBestSummonCase(){

    }
    <span class="directive">public</span> Case findBestMagicCase(){

    }
    <span class="directive">public</span> Case findBestSupportCase(){

    }
    <span class="directive">public</span> Case findBestOveralCase(){}

    <span class="comment">// self evaluation</span>
    <span class="directive">public</span> <span class="type">float</span> evalGoodToAttack(Card card){

    }
    <span class="directive">public</span> <span class="type">float</span> evalGoodToDefend(Card card){

    }
    <span class="comment">/* This function evaluate the value of these two cards when the AI choose to support targetCard with the approriate supportCard*/</span>
    <span class="directive">public</span> <span class="type">float</span> evalGoodToSupport(Card targetCard,Card supportCard){

    }
    <span class="comment">/* This function evaluate the value of this card when they want to keep or discard it by purpose */</span>
    <span class="directive">public</span> <span class="type">float</span> evalGoodOveral(Card card){

    }
    <span class="comment">// Rule</span>
    <span class="directive">public</span> <span class="type">boolean</span> canSummon(Card aCard){

        <span class="comment">// enough tribute</span>
        <span class="type">int</span> stars = aCard.level.toInteger()
        <span class="type">boolean</span> enoughStar=<span class="predefined-constant">false</span>;
        <span class="keyword">if</span> ( stars &gt; <span class="integer">6</span>){
            <span class="keyword">if</span> (stars <span class="error">–</span> <span class="integer">5</span> &gt; player.ground.size()){
                enoughStar =<span class="predefined-constant">true</span>
            } <span class="keyword">else</span> {
                enoughStar =<span class="predefined-constant">false</span>
            }

        } <span class="keyword">else</span> {
            enoughStar=<span class="predefined-constant">true</span>;
        }
        <span class="comment">//(!aCard.summonCancel) &amp;&amp; &amp;&amp; sastifySummonCondition(aCard)</span>
        <span class="keyword">return</span> (enoughStar &amp;&amp; aCard.isMonsterCard());
    }

}</code></pre></div></div>
<div class="paragraph"><p>And the way to call it … CardGamePlay</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">            <span class="keyword">case</span> MainPhase:
                <span class="keyword">if</span> (!currentTurn.player.aiPlayer){
                    <span class="keyword">if</span> (isPlayerChangePhase(MainPhase)){
                        nextPhase()
                    } <span class="keyword">else</span> {
                        humanSelectFunction();
                    }
                } <span class="keyword">else</span> {
                    println(currentTurn.player.ai);
                    currentTurn.player.ai.think();
                    currentTurn.player.ai.act();
                }</code></pre></div></div>
<div class="paragraph"><p>The fun things here are we delayed Action we want the AI and save to Actions list made from Closure. In the main loop, we wait till ai.act is called then execute all the delayed action. The power of Groovy once again shown! By this technique we can easily introduce paralel computing with an cool ulitities of Groovy named <a href="../../../jme3/atomixtuts/cardsgame/gpars.html">GPars</a>. But we don’t use it right now though !</p></div></div></div></div><div id="footer"><div id="footer-text">Version <br>Last updated 2017-11-14 05:28:25 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>