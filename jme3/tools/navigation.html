<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><title>Introduction to Marine Navigation</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/jMonkeyEngine/wiki/edit/master/src/docs/asciidoc/jme3/tools/navigation.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/jMonkeyEngine/wiki/new/master/src/docs/asciidoc/jme3/tools/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>Introduction to Marine Navigation</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version ,</span> <span id="revdate">2016/03/17 20:48</span></div><div id="toc" class="toc2"><div id="toctitle">Table of Contents</div><ul class="sectlevel1"><li><a href="#chart-projection">Chart Projection</a></li></ul></div></div><div id="content"><div id="preamble"><div class="sectionbody"><div class="paragraph"><p>This article describes JME&#8217;s mercator projection tool. If you don&#8217;t know what this means, we suggest you begin by reading <a href="http://en.wikisource.org/wiki/The_American_Practical_Navigator">The American Practical Navigator</a> or browsing Wikipedia. If you do know what a Mercator projection is, then our “Introduction to Marine Navigation might serve to refresh your mind.</p></div>
<div class="paragraph"><p><a href="http://en.wikipedia.org/wiki/Latitude">Wikipedia</a> is a source for formulas shown here. Read it. Absorb it.</p></div>
<div class="paragraph"><p><strong>Terms, Conventions and Definitions</strong>
<strong>Charts</strong> are defined as “graphic representations of areas of the earth for use in marine or air navigation whereby nautical charts depict features of particular interest to the marine navigator[1].</p></div>
<div class="paragraph"><p><strong>Prime Meridian</strong> designates the Greenwich meridian as of 1884.</p></div>
<div class="paragraph"><p><strong>Distance</strong> is designated in nautical miles whereby one nautical mile corresponds to one meridian arc minute (1,852 metres) at the equator.</p></div>
<div class="paragraph"><p><strong>Sailing</strong> refers to various mathematical methods for determining course, distance, and position.
<strong>Speed</strong> refers to the rate of motion, or distance per unit of time and is measured in knots (kn). One knot is equal to one nautical mile per hour.</p></div>
<div class="paragraph"><p><strong>Coordinates</strong>
The purpose of coordinates is to define a distinct position on earth. For the purpose of this project, only latitude and longitude are of importance, although the reader should be aware that other coordinate systems exists such as UMT (Universal Transverse Mercator) and UPS (Universal Polar Stereographic).</p></div>
<div class="paragraph"><p>Latitude is the angular distance from the equator, measured northward or southward along a meridian from 0◦ at the equator to 90◦ at the poles[1]. Within aviation and maritime navigation, latitude is designated north (N) or south (S) to indicate the direction of measurement. An equally valid notation designates north (N) to be positive and south (S) to be negative. For example 18◦ N becomes 18 whilst 18◦ S becomes -18.
Longitude is the angular distance between the prime meridian and the meridian of a point on the earth, measured eastward or westward from the prime meridian through 180◦. It is designated east (E) or west (W) to indicate the direction of measurement[1] however similar to angular measurements from the equator, may be expressed in terms of negative (W) and positive (S). For ex- ample 18◦ E becomes 18 whilst 18◦ W becomes -18.
It is worth noting that degrees can be further subdivided into minutes, whereby one degree equals 60 minutes. Minutes in turn are subdivided into seconds whereby each minute equals 60 seconds.	Latitude and longitude coordinates are therefore typically specified as degrees (◦), minutes (’) and seconds (”).</p></div>
<div class="paragraph"><p>For example: 1◦ 2’ 3” W meaning 1 degree, 2 minutes and 3 seconds West. This in turn can be translated into decimal notation whereby degrees are expressed as a decimal fraction: therefore 1◦ 2’ 3” W would become -1.034167. Alternatively these angular measurements may be converted to radians (in which case they would be expressed as a signed fraction of π).
The difference of latitude between two places is the angular length of arc of any meridian between their parallels. That is, it is the numerical difference of the latitudes if the places are on the same side of the equator or the sum of the latitudes if the points are on opposite sides of the equator.[1]</p></div>
<div class="paragraph"><p>Similarly, the difference of longitude between two places is the shorter arc of the parallel or the smaller angle at the pole between the meridians of the two places. If both places are on the same side (i.e east or west) of Greenwich, then difference of longitude is the numerical difference of the longitudes of the two places; otherwise the difference of longitude is their numerical sum (unless of course this exceeds 180◦. In that case it is 360◦ minus the sum).</p></div>
<div class="paragraph"><p><span class="image"><img src="../../jme3/tools/globe_lat_long.png" alt="Figure 1: Illustrated latitude (φ) and longitude (λ). Photo courtesy of Wikimedia Inc." width="" height=""></span></p></div>
<div class="paragraph"><p><strong>Meridional Parts</strong>
As described by Bowditch, Meridional parts are ”units of latitude that have been adjusted to compensate for the distortion that results from projecting a three-dimensional globe onto a two-dimensional Mercator chart”.</p></div>
<div class="paragraph"><p><strong>Bearing</strong>
In marine navigation, bearing is defined as ”the direction one object is from another object, usually, the direction of an object from one’s own vessel”. Note that this is not to be confused with the equivalent term within aviation were bearing refers to ”the actual (corrected) compass direction of the forward course of the aircraft.”</p></div>
<div class="paragraph"><p><strong>Heading and Course</strong>
Heading is the direction in which a vessel is pointed and is expressed as degrees from 0 to 359.
Course is the over ground track in which a vessel moves. With wind, water movement and steering error, heading and course are not necessary equal.</p></div>
<div class="paragraph"><p><strong>Mercator Projection</strong>
Mercator projections are a standard within nautical charts an represent rhumb lines (a.k.a loxodromes) as straight segments. A mercator projection is of non- linear scale as it accounts for distortion in latitude as one moves away from the Equator and towards the poles (with the poles being defined as infinity. This notion is illustrated to the right by figure 1.2). These distortions arise from the fact that the earth is an oblate spheriod i.e. a sphere with a flattened top and bottom (the poles). Therefore, as one moves away from the equator, nautical metrics skew to the extend whereby the length of one degree of latitude along the poles covers approximately 1 percent more distance than at the equator.</p></div></div></div>
<div class="sect1"><h2 id="chart-projection">Chart Projection</h2><div class="sectionbody"><div class="paragraph"><p>A Mercator projection is defined by its meridians and parallels, both of which are expanded at an equal ratio with increasing latitude. This expansion is due to the distortion that results from projecting an oblate spheroid onto a two- dimensional surface (see introductory notes above) and equates to the secant of the latitude in addition to a correction for this distortion. Note that the secant of 90◦ is infinity, and therefore Mercator projections cannot include the poles (thus the mercator projection employed here stops at 85◦ North and South of the equator).</p></div>
<div class="paragraph"><p>Rhumb lines appear as straight lines.</p></div>
<div class="paragraph"><p>The projection calculations are handled by the <code>MapModel2D</code> class, in the case of 2D, and by <code>MapModel3D</code>, in the case of a 3D projection. Fundamentally both projections function in the same manner, with their only real differences being that <code>MapModel3D</code> introduces an extra co-ordinate (z) and the replacement of the <code>toPixel()</code> method with <code>toWorldUnit()</code> which converts a latitude/longitude coordinate object into (x,y,z) world units as opposed to pixel (x,y) coordinates.
The core functionality of the entire system relies on the accurate conversion of latitude/longitude into pixels/world units and vice versa. These conversions are handled by <code>toPixel()</code>, <code>toWorldUnit()</code> and <code>toPosition()</code> respectively.
Note that all sailings used by this class are located inside the NavCalculator class and will be elaborated upon in the next section of this chapter.</p></div>
<div class="paragraph"><p><strong>Minutes per pixel / Minutes per World Unit</strong>
The number of pixels or world units per minute serves as a baseline for all coordinate conversions and is derived by dividing the total number of minutes of longitude composing the chart (i.e. 360 * 60) by the width of the canvas on which to render the projection (aka viewport):
<code>minutesPerPixel = (mapWidthInLongitude * 60) / (double) viewportWidth;</code></p></div>
<div class="paragraph"><p><strong>toPixel</strong>
Unlike commonly assumed, this method is not derived from the inverse Guder- mannian function. Accepting a set of latitude/longitude coordinates encapsulated in a Position object as a parameter, the method returns the equivalent pixel (x, y) encapsulated as a Point object. This conversion can be summarized as follows[2]:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Ordered List Item Get the distance between the given position’s longitude coordinate and the chart’s longitude centre.</p></li><li><p>Convert the obtained distance into pixels by dividing it with the number of pixels that are contained within one minute. Refer to it as distanceInPixels.</p></li><li><p>Calculate the x-coordinate by subtracting or adding it to the canvas’ x-centre coordinate (the canvas’ x-centre coordinate being the canvas width di- vided by two) depending on the location of the position itself and the chart’s centre: That is, if the chart is centred west of the prime meridian and if the position to be converted is west of the centre, then the resulting x-coordinate is the difference between the x-centre and the distanceInPixels obtained in step 2 above. If however the centre is West and the position is east of the centre, then the resulting x-coordinate equates to the sum of the x-centre and its dis- tanceInPixels. The opposite is true for an easterly centre and a position west of this centre or an easterly centre and a position east of this centre.</p></li><li><p>Ordered List Item For the y-coordinate, the difference in meridional parts between the chart’s latitude centre and the position’s latitude serves as a baseline. Con- vert the difference to pixels by dividing it by the number of pixels contained</p></li></ol></div>
<div class="paragraph"><p>within one minute. Refer to it as dmp1.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Ordered List Item Similar to step 3 above, calculate the y-coordinate by subtracting or</p></li></ol></div>
<div class="paragraph"><p>adding it to the canvas’ y-centre coordinate (the canvas’ y-centre being the canvas height divided by two) depending on the location of the position itself and the chart’s centre: That is, if the centre is north and the position is north of the centre, then the resulting y-coordinates equates to the difference between dmp and the y-centre coordinate. If however the centre is north but the position is south of the centre, then the resulting y-coordinate equates to their sum. The opposites are true given that the centre lies in the southern hemisphere.</p></div>
<div class="paragraph"><p>The following converts a latitude/longitude coordinate pair into a JME world-unit vector:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">try</span> {
    <span class="type">int</span> worldWidth = <span class="integer">800</span>;
    MapModel3D m = <span class="keyword">new</span> MapModel3D(worldWidth);
    Vector3f v = m.toWorldUnit(<span class="keyword">new</span> <span class="predefined-type">Position</span>(-<span class="integer">53</span>, <span class="float">8.0</span>));
} <span class="keyword">catch</span> (InvalidPositionException e) { e.printStackTrace(); }</code></pre></div></div>
<div class="paragraph"><p>To convert world units into latitude/longitude coordinates, use the map model’s toPosition method:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">try</span> {
     <span class="type">int</span> worldWidth = <span class="integer">800</span>; MapModel3D m = <span class="keyword">new</span> MapModel3D(worldWidth);
     <span class="predefined-type">Position</span> pos = m.toPosition(<span class="keyword">new</span> Vector3f(<span class="integer">10</span>, <span class="integer">10</span>, <span class="integer">10</span>));
     <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Latitude: </span><span class="delimiter">&quot;</span></span> + pos.getLatitude() + <span class="string"><span class="delimiter">&quot;</span><span class="content"> Longitude: </span><span class="delimiter">&quot;</span></span> + pos.getLongitude());
} <span class="keyword">catch</span> (InvalidPositionException e) {
     e.printStackTrace();
}</code></pre></div></div>
<div class="paragraph"><p>Navigational calculations are performed inside the <code>NavCalculator</code> class.</p></div>
<div class="paragraph"><p><strong>Mercator Sailing</strong>
Mercator sailing is defined as ’the process of solving problems involving course, distance, difference of latitude and difference of longitude, by considering them in relation to a Mercator chart’[1]. Essentially, this refers to the plotting of a rhumb line2 on a Mercator chart whereby the rhumb line will appear as a straight line. That is, given a constant bearing β north of the rhumb line, longitude λ0 where the line passes the equator, λ1 being any longitude point of the rhumb line, and φ being any latitude point on the rhumb line then its Mercator projection can be derived as:</p></div>
<div class="ulist"><ul><li><p>x = λ1</p></li><li><p>y = m(λ1 − λ0)</p></li></ul></div>
<div class="paragraph"><p>where slope m is cot(β), then λ and φ can be expressed as</p></div>
<div class="ulist"><ul><li><p>x = λ1</p></li><li><p>y = tanh−1(sin(φ) φ = sin−1(tanh(m(λ1 − λ0)))</p></li></ul></div>
<div class="paragraph"><p>That is, tan(course) = (differenceinlongitude)/(differenceinmeridionalparts)
and distance = (differenceinlatitude/cos(course)) where the difference in meridional parts is defined in terms of a Clarke Spheroid.</p></div>
<div class="paragraph"><p>This is implemented as follows where <code>RLSailing</code> and <code>Position</code> are wrapper classes.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> RLSailing mercatorSailing(<span class="predefined-type">Position</span> p1, <span class="predefined-type">Position</span> p2) {
     <span class="type">double</span> dLat = computeDLat(p1.getLatitude(), p2.getLatitude());
     <span class="keyword">if</span> (dLat == <span class="integer">0</span>) {
          RLSailing rl = planeSailing(p1, p2); <span class="keyword">return</span> rl;
     }
     <span class="type">double</span> dLong = computeDLong(p1.getLongitude(), p2.getLongitude());
     <span class="type">double</span> dmp = (<span class="type">float</span>) computeDMPClarkeSpheroid(p1.getLatitude(), p2.getLatitude());
     trueCourse = (<span class="type">float</span>) <span class="predefined-type">Math</span>.toDegrees(<span class="predefined-type">Math</span>.atan(dLong / dmp));
     <span class="type">double</span> degCrs = convertCourse((<span class="type">float</span>) trueCourse, p1, p2);
     distance = (<span class="type">float</span>) <span class="predefined-type">Math</span>.abs(dLat / <span class="predefined-type">Math</span>.cos(<span class="predefined-type">Math</span>.toRadians(trueCourse)));

     RLSailing rl = <span class="keyword">new</span> RLSailing(degCrs, (<span class="type">float</span>) distance);
     trueCourse = rl.getCourse();
     <span class="keyword">return</span> rl;
}</code></pre></div></div>
<div class="paragraph"><p>where <em>dmp</em> refers to the difference in meridional parts.</p></div>
<div class="paragraph"><p><strong>Difference in Meridional Parts</strong>
Meridional parts are units of latitude that have been adjusted to compensate for the distortion that results from projecting an oblate spheroid onto a two- dimensional surface.</p></div>
<div class="paragraph"><p>Although other datums (such as WGS 84) are equally valid, the navigation module performs all calculations within the context of the Clarke spheroid of 1880 which has an equatorial radius of 6,378,249.145 meters, a polar radius of 6,356,514.870 meters and an inverse flattening of 293.465 meters.
The meridional part for any latitude L is therefore defined as:
M = 7915.704468 ∗ log(tan(45 + (L/2))) − 23.268932 ∗ (sin(L)) − 0.052500 ∗ (sin(L))3 − 0.000213 ∗ (sin(L))5</p></div>
<div class="paragraph"><p>Where m1 and m2 refer to the meridional parts of the offset and destination point respectively, the difference of meridional parts is calculated as |m1 − m2| if both points are north, or south of the equator or as their sum if one of the points is north and the other south of the equator:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">double</span> computeDMPClarkeSpheroid(<span class="type">double</span> lat1, <span class="type">double</span> lat2) {
     <span class="type">double</span> absLat1 = <span class="predefined-type">Math</span>.abs(lat1); <span class="type">double</span> absLat2 = <span class="predefined-type">Math</span>.abs(lat2);
     <span class="type">double</span> m1 = (<span class="float">7915.704468</span> * (<span class="predefined-type">Math</span>.log(<span class="predefined-type">Math</span>.tan(<span class="predefined-type">Math</span>.toRadians(<span class="integer">45</span> + (absLat1 / <span class="integer">2</span>)))) / <span class="predefined-type">Math</span>.log(<span class="integer">10</span>)) - <span class="float">23.268932</span> * <span class="predefined-type">Math</span>.sin(<span class="predefined-type">Math</span>.toRadians(absLat1)) - <span class="float">0.052500</span> * <span class="predefined-type">Math</span>.pow(<span class="predefined-type">Math</span>.sin(<span class="predefined-type">Math</span>.toRadians(absLat1)), <span class="integer">3</span>) - <span class="float">0.000213</span> * <span class="predefined-type">Math</span>.pow(<span class="predefined-type">Math</span>.sin(<span class="predefined-type">Math</span>.toRadians(absLat1)), <span class="integer">5</span>));
<span class="type">double</span> m2 = (<span class="float">7915.704468</span> * (<span class="predefined-type">Math</span>.log(<span class="predefined-type">Math</span>.tan(<span class="predefined-type">Math</span>.toRadians(<span class="integer">45</span> + (absLat2 / <span class="integer">2</span>)))) / <span class="predefined-type">Math</span>.log(<span class="integer">10</span>))
- <span class="float">23.268932</span> * <span class="predefined-type">Math</span>.sin(<span class="predefined-type">Math</span>.toRadians(absLat2)) - <span class="float">0.052500</span> * <span class="predefined-type">Math</span>.pow(<span class="predefined-type">Math</span>.sin(<span class="predefined-type">Math</span>.toRadians(absLat2)), <span class="integer">3</span>) - <span class="float">0.000213</span> * <span class="predefined-type">Math</span>.pow(<span class="predefined-type">Math</span>.sin(<span class="predefined-type">Math</span>.toRadians(absLat2)), <span class="integer">5</span>));
     <span class="keyword">if</span> ((lat1 &lt;= <span class="integer">0</span> &amp;&amp; lat2 &lt;= <span class="integer">0</span>) || (lat1 &gt; <span class="integer">0</span> &amp;&amp; lat2 &gt; <span class="integer">0</span>)) {
          <span class="keyword">return</span> <span class="predefined-type">Math</span>.abs(m1 - m2);
     } <span class="keyword">else</span> {
          <span class="keyword">return</span> m1 + m2;
     }
}</code></pre></div></div>
<div class="paragraph"><p><strong>Course Conversion</strong>
The conversion of a true course to its equivalent compass course (i.e. con- version of true course to the targets course over ground (COG) where ’true course’ is defined as the course to be steered from true north3) as used by the <code>mercatorSailing</code> method is achieved by subtracting the course variation from the true course, where variation is the angular difference between true north and the direction of the Earth’s magnetic field (consequently variation is termed East or West depending on the target’s position relative to true north).
Given the true course between two positions, the COG is calculated by calling NavCalculator.convertCourse(tc, p1, p2)</p></div>
<div class="paragraph"><p><strong>Difference in Latitude</strong>
The difference in latitude depends on the hemisphere in which both positions are can be determined by calling <code>NavCalculator.computeDLat(lat1, lat2)</code>.</p></div>
<div class="paragraph"><p><strong>Difference in Longitude</strong>
Similar to the difference in latitude, the difference in longitude depends on which side of the prime meridian both positions are in and can be determined by calling NavCalculator.computeDLong(long1, long2).</p></div>
<div class="paragraph"><p><strong>Bearing</strong>
The direction that one target is from another. Given the latitude of two points (φ0andφ1) and the longitude of two points(λ0andλ1), bearing (θ) is defined as follows:
Let dLon be the difference in longitude of λ0andλ1, then</p></div>
<div class="ulist"><ul><li><p>x = (sin(dLon) ∗ cos(φ1)</p></li><li><p>y = cos(φ0) ∗ sin(φ1) − sin(φ0) ∗ cos(φ1) ∗ cos(dLon))</p></li><li><p>θ = 2arctan√ θ = atan2(y, x)</p></li><li><p>y</p></li></ul></div>
<div class="paragraph"><p>x2+y2+x</p></div>
<div class="paragraph"><p>Which can be determined as follows:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">try</span> {
     <span class="type">double</span> bearing = NavCalculator.computeBearing(<span class="keyword">new</span> <span class="predefined-type">Position</span>(-<span class="float">53.6</span>, <span class="float">8.1</span>), <span class="keyword">new</span> <span class="predefined-type">Position</span>(-<span class="integer">53</span>, <span class="integer">8</span>.
  } <span class="keyword">catch</span> (InvalidPositionException e) {
     e.printStackTrace();
  }</code></pre></div></div>
<div class="paragraph"><p>[1] Nathaniel Bowditch (1995), The American Practical Navigator,. United States Government, National Ocean Service Publishing.
[2] Gebruers C., “JMarine</p></div></div></div></div><div id="footer"><div id="footer-text">Version <br>Last updated 2017-11-14 05:28:25 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>