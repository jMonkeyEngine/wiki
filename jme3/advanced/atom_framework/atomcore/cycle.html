<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><title>cycle</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/jMonkeyEngine/wiki/edit/master/src/docs/asciidoc/jme3/advanced/atom_framework/atomcore/cycle.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/jMonkeyEngine/wiki/new/master/src/docs/asciidoc/jme3/advanced/atom_framework/atomcore/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>cycle</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version ,</span> <span id="revdate">2016/03/17 20:48</span></div><div id="toc" class="toc2"><div id="toctitle">Table of Contents</div><ul class="sectlevel1"><li><a href="#well-defined-cycles">Well defined Cycles</a><ul class="sectlevel2"><li><a href="#why-6">Why 6?</a></li><li><a href="#pull-or-push">Pull or push?</a></li></ul></li><li><a href="#customable-cycles">Customable cycles</a><ul class="sectlevel2"><li><a href="#customable-routines">Customable routines</a></li></ul></li><li><a href="#cycle-scale">Cycle &amp; Scale</a></li><li><a href="#technical-reviews">Technical reviews</a><ul class="sectlevel2"><li><a href="#cycle-or-ring">Cycle (or ring)</a></li></ul></li></ul></div></div><div id="content"><div class="sect2"><h3 id="well-defined-cycles">Well defined Cycles</h3><div class="paragraph"><p>Cycle are ordered activities which repeat over and over during the entire application life time. It&#8217;s usually referred as game loop.</p></div>
<div class="paragraph"><p>If you see a cycle as a list (ordered collection) of actions that the application does one at a time. You will see the application Iterate over them. In the opposite view (or in the action body), a traveller (usually data) seen it drag from one to the next one, so call pull to next step.</p></div>
<div class="paragraph"><p>As Atom also support reactive programming, it&#8217;s essential that developer should understand clearly what is the benefit of program with this direction or other. To get (Between) BEST OF BOTH WORLD!</p></div>
<div class="sect2"><h3 id="why-6">Why 6?</h3><div class="paragraph"><p>Game programmer usually stick with 3 steps execution</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>init</p></li><li><p>update</p></li><li><p>destroy</p></li></ol></div>
<div class="paragraph"><p>Instead of that, Atom use 6 steps execution cycle:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>init</p></li><li><p>start</p></li><li><p>load</p></li><li><p>config</p></li><li><p>update</p></li><li><p>finish</p></li></ol></div>
<div class="paragraph"><p>These 6, I carefully learnt from other “good module and component framework I 've use: Wicket, OSGi,Spring…they have different steps number!</p></div>
<div class="paragraph"><p><a href="http://wicketguide.comsysto.com/guide/chapter6.html#chapter6_1">http://wicketguide.comsysto.com/guide/chapter6.html#chapter6_1</a></p></div>
<div class="paragraph"><p><a href="http://en.wikipedia.org/wiki/OSGi#Life-cycle">http://en.wikipedia.org/wiki/OSGi#Life-cycle</a></p></div>
<div class="paragraph"><p><a href="http://www.tutorialspoint.com/spring/spring_bean_life_cycle.htm">http://www.tutorialspoint.com/spring/spring_bean_life_cycle.htm</a></p></div>
<div class="paragraph"><p>The reason of these 6 step routine compare to 2,3,4,5.. or any other division is to support lazy loading, heavy task, gabage collection wise, much more…</p></div>
<div class="paragraph"><p>So we usually have these 3 main methods:</p></div>
<div class="literalblock"><div class="content"><pre>init , start , end</pre></div></div>
<div class="paragraph"><p>For a real-time game, we need 2 more:</p></div>
<div class="literalblock"><div class="content"><pre>load, update</pre></div></div>
<div class="paragraph"><p>“Config method is kind of a replicate of “init or “load, or confusion of these two, even can be done in “update somehow but in fact, it&#8217;s worth to be separated. The config step will help you gain a lot in the way to extend the frameworks or to adapt/scale  your game to smaller or bigger usecase, anyway 6 “is not too much but enough !</p></div>
<div class="paragraph"><p>Anyway this is a common cycle and compromise between ICycle who join the Atom conversations; that&#8217;s hook in methods (classic style isn&#8217;t it?). Beside of that, you can define your own routines through safe tasks and channels which provided by AtomMain. Though this tunnels, all your operations are guarantee to be not conflict in concurrent term with any other jobs of Managers, actors or helpers. So the Data is for you until you end the tasks (or be shut by forced because timeout for ex)!!</p></div></div>
<div class="sect2"><h3 id="pull-or-push">Pull or push?</h3><div class="paragraph"><p>As said in the analysis about JME3&#8217;s patterns, especially rendering and update loop, it&#8217;s pull and push at the same time. Confused? Yes it&#8217;s… Why is so confused?</p></div>
<div class="paragraph"><p>Java developers are “toooo familiar with MVC architecture that bring to us by Swing and all classic sun solutions. That&#8217;s why we find them in every programming books and every beginner&#8217;s articles, especially if you develops game in desktop, (obviously in swing also). OpenGL and LWJGL also start as window based solution. So that we get “used to it… Latter, a lot of web frameworks also make tanged mess of push &amp; pull concepts?</p></div>
<div class="paragraph"><p>Swing-MVC concepts are embeded in a event-driven enviroment… and it&#8217;s actually pull.</p></div>
<div class="paragraph"><p>Real-time application can be event-driven or not. As my exprience, apply this Swing-MVC to real-time application not usually help greatly but sounds very confused and blury. It can help if you too familiar with it anyway, but be careful or you break the MVC contracts easily and make it not useful. You can blindy apply it without concerning of consequence, but that don’t make any sense.</p></div>
<div class="paragraph"><p>The solid and only reason to say JME3 is pull and push, and why we still has to stop once for a while because of OpenGL via LWJGL is still monotholic! Not the GPU processing or GPU-CPU data exchange. So we still have to stop at the renderer&#8217;s door, knock and wait until its done, then go to next step? Umh not quite.</p></div>
<div class="paragraph"><p>But to do this, we have to not depend in the update() and render() methods to get to total freedom.</p></div>
<div class="sect3"><h4 id="concurrent-parallel-world">Concurrent / Parallel world</h4><div class="paragraph"><p>Welcome to the parallel world which some time the well-defined cycle not even exist.</p></div>
<div class="paragraph"><p>But the routine or the flow does exist indeed!</p></div>
<div class="paragraph"><p>Just look at how your “data or “signal actually run through your systems, though “node and “stages as a network of roads &amp; cars. This actually a well-study area known as data flow analysis. In a perspective, data seem to be “pushed from sources to targets. Some may also view its as data are “requested by some nodes and “pulled by those nodes.</p></div>
<div class="paragraph"><p><a href="https://github.com/Netflix/RxJava/wiki">https://github.com/Netflix/RxJava/wiki</a></p></div></div>
<div class="sect3"><h4 id="what-is-the-new-routines-options">What is the new routines options?</h4><div class="paragraph"><p>Even if “Cycle- which we used to known is just a conceptual view of points, my solution for this problem is to declare several new kinds of well-defined “Cycle :</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Push cycle</p></li><li><p>Pull cycle</p></li><li><p>Non-cycle</p></li></ol></div>
<div class="paragraph"><p>… because defining routines in Atom is not only free but also helps in a lot of situations like when you interact with GUIs, networks or webs.</p></div>
<div class="sect4"><h5 id="pull-cycle">Pull cycle</h5><div class="paragraph"><p>To connect to Swing MVC (also a pull cycle) with events, you can wrap them in Actors and let events send as messages between actors. The Swing actor in the EDT act as the brigde here.</p></div></div>
<div class="sect4"><h5 id="push-cycle">Push cycle</h5><div class="paragraph"><p>As in functional reactive programming and flow based programming, functions (small piece of jobs) are flow with their data. A flow is not a well defined cycle but a routine and can be monitored.</p></div></div>
<div class="sect4"><h5 id="non-cycle">Non-cycle</h5><div class="paragraph"><p>A serial of Tasks can also form atribinary routines ( non-cycle) and be coordinated together via Data they exchange.</p></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="fa icon-tip" title="Tip"></i></td><td class="content"><div class="paragraph"><p>Goto AtomPar for more concurrent/ paralell concepts and advices</p></div></td></tr></table></div></div></div></div></div>
<div class="sect2"><h3 id="customable-cycles">Customable cycles</h3><div class="sect2"><h3 id="customable-routines">Customable routines</h3><div class="paragraph"><p>Via tasks and workers, you can atribinary make your own cycle that do anything around and later participate in the rendering stage and JME logic stage (if they want).</p></div>
<div class="paragraph"><p>This freedom of doing things (in parallel if you want) is thanks to lock-free concurrent algorimths and data structure that Atom use. In other hand, the synchonizing problem is under research!</p></div>
<div class="paragraph"><p>Read: <a href="../../../../jme3/advanced/atom_framework/atomcore/concurrent.html">AtomPar</a></p></div>
<div class="sect3"><h4 id="customable-rendering-bucket">Customable (rendering) bucket</h4><div class="paragraph"><p>Bucket is a way to layered your rendering queue into layers or separate them into different categories (aka buckets) to handle differently.</p></div>
<div class="paragraph"><p>With a composable comperator, a sub-list from a list, or a sub-tree from a tree, even a sub-graph from a entire scene graph can be extracted, or the whole collection can be sorted arcordingly. Custom bucket in Atom framework is implemented in AtomLight package to extend JME3 rendering pipeline.</p></div>
<div class="paragraph"><p>Note that a custom bucket is not very efficient! Even though if you enable a setting, Atom will take care of its render order and the update will be “IO wise with special indexing structure call B-Tree. If you use it without cautions it can require a lot of memory and make your rendering suffer.</p></div></div></div></div>
<div class="sect1"><h2 id="cycle-scale">Cycle &amp; Scale</h2><div class="sectionbody"><div class="paragraph"><p>You can see there is a trend for networks call non blocking IO, which Node.js is the first most and remarkable success. In that world, there is actually not a wellform cycle or turn at all. Because if there is a Queue or a lock, a insist port holder or an strict order (like a cycle), it can not scale at all!!</p></div>
<div class="paragraph"><p>In fact the atribinary networks and async data signals have a lot more problems than we can possible imagine. Not everything can be fast and precise…Some parts (services) may be slow by intend, some parts cause errors frequently.</p></div>
<div class="paragraph"><p>The fault torrent architecture of AtomEx make sure some sercurity and transactional problems are shielded. AtomDust in another hand focus in highly loose mobile devices and atribinay short range connections. Those carefully design systems for usecases actually make Atom suitable even without a real Cycle.</p></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="fa icon-tip" title="Tip"></i></td><td class="content"><div class="paragraph"><p>Read more about AtomEx for Cloud scale and AtomDust of Mobile scale.</p></div></td></tr></table></div></div></div>
<div class="sect2"><h3 id="technical-reviews">Technical reviews</h3><div class="sect2"><h3 id="cycle-or-ring">Cycle (or ring)</h3><div class="sect3"><h4 id="cicular-or-ring-buffer">Cicular (or ring) buffer</h4><div class="paragraph"><p>Ring buffer is fast way to make concurrent real time data streaming…</p></div>
<div class="paragraph"><p><a href="http://mechanitis.blogspot.com/2011/06/dissecting-disruptor-whats-so-special.html">http://mechanitis.blogspot.com/2011/06/dissecting-disruptor-whats-so-special.html</a></p></div></div>
<div class="sect3"><h4 id="is-there-a-real-cycle-or-just-a-lot-of-streams">Is there a real cycle? or just a lot of streams</h4></div></div></div></div><div id="footer"><div id="footer-text">Version <br>Last updated 2017-11-14 05:28:25 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>