<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><title>design</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/jMonkeyEngine/wiki/edit/master/src/docs/asciidoc/jme3/advanced/atom_framework/design.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/jMonkeyEngine/wiki/new/master/src/docs/asciidoc/jme3/advanced/atom_framework/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>design</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version ,</span> <span id="revdate">2016/03/17 20:48</span></div><div id="toc" class="toc2"><div id="toctitle">Table of Contents</div><ul class="sectlevel1"><li><a href="#atom-framework-design">Atom Framework Design</a><ul class="sectlevel2"><li><a href="#motivation">Motivation</a></li><li><a href="#overview">Overview</a></li></ul></li><li><a href="#design-goals">Design goals</a><ul class="sectlevel2"><li><a href="#overal-goals">Overal goals</a></li><li><a href="#slides">Slides</a></li></ul></li><li><a href="#real-time-applications">Real time applications</a><ul class="sectlevel2"><li><a href="#atom-vs-ptolemy">Atom VS ptolemy</a></li><li><a href="#atom-vs-jscience">Atom VS JScience</a></li><li><a href="#target-devices-platforms">Target Devices &amp; Platforms</a></li></ul></li><li><a href="#problems">Problems</a></li><li><a href="#solutions-frameworks-platforms">Solutions &amp; Frameworks &amp; Platforms</a></li><li><a href="#atom-framework-design-course">Atom framework Design course</a><ul class="sectlevel2"><li><a href="#game-and-real-time-application">Game and real-time application</a></li><li><a href="#atomcore-architecture">AtomCore Architecture</a></li><li><a href="#design-patterns-programming-paradigms">Design patterns &amp; Programming paradigms</a></li><li><a href="#programming-aspects">Programming aspects</a></li><li><a href="#polygot-programming">Polygot programming</a></li><li><a href="#modular-architecture">Modular architecture</a></li></ul></li><li><a href="#enterprise-facilities">Enterprise facilities</a><ul class="sectlevel2"><li><a href="#services-dependency-and-decoupling">Services, Dependency and Decoupling</a></li><li><a href="#available-services">Available Services</a></li></ul></li><li><a href="#monitoring-and-development-workflow">Monitoring and development workflow</a></li><li><a href="#future-vision">Future vision</a></li><li><a href="#references-and-inspiration">References and Inspiration</a></li></ul></div></div><div id="content"><div class="sect2"><h3 id="atom-framework-design">Atom Framework Design</h3><div class="paragraph"><p>This is the repository resulted of the design phase of Atom framework over years.</p></div>
<div class="sect2"><h3 id="motivation">Motivation</h3><div class="paragraph"><p>It born to helps JME3 focus in <strong>game/simulation development</strong>, push futher in lastest/future Java technologies toward to enterpise/AAA game dev as its final goal, but compromise/ compatible with existing insfracture of JME3 and OpenGL.</p></div>
<div class="paragraph"><p>Its concept, design and archictecture inspired by AAA game engine and Enterprise Java solution.</p></div></div>
<div class="sect2"><h3 id="overview">Overview</h3><div class="paragraph"><p>In this page:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Goal of Atom framework - which tend to expand JME3 and Java language to suite more for game dev.</p></li><li><p>Problems of realtime applications (especially games).</p></li><li><p>Solutions and those base platforms, frameworks that we going to use to approach those goals.</p></li><li><p>Remain works and future vision</p></li></ol></div></div></div>
<div class="sect2"><h3 id="design-goals">Design goals</h3><div class="sect2"><h3 id="overal-goals">Overal goals</h3><div class="ulist"><ul><li><p>Flexible: Game | simulations centric but not forced!</p></li><li><p>Modular: Dependency injection along with Component injection</p></li><li><p>Parallel: Embrace parallel computing</p></li><li><p>Next gen: Come with Bleeding edge technologies and powers of Java languages</p></li><li><p>Cloud ready: Scale to web and distributed computing</p></li><li><p>With ease: <abbr title="Graphical User Interface">GUI</abbr> Tools everywhere, almost zero config need</p></li><li><p>Cross devices: Can run wide range of devices PC-mobile-TV.. any one that has java!</p></li></ul></div>
<div class="sect3"><h4 id="additional-sub-goals">Additional sub goals</h4><div class="ulist"><ul><li><p>Minimum dependencies and their overlap</p></li><li><p>Small footprint &amp; Efficient</p></li></ul></div></div></div>
<div class="sect2"><h3 id="slides">Slides</h3><div class="paragraph"><p>You can view slides and download papers about the design of Atom framework here.</p></div></div></div>
<div class="sect2"><h3 id="real-time-applications">Real time applications</h3><div class="paragraph"><p>Atom is designed to <strong>MAKE</strong> concurrent, real-time, embedded systems and <strong>GAMES</strong></p></div>
<div class="sect2"><h3 id="atom-vs-ptolemy">Atom VS ptolemy</h3><div class="paragraph"><p>As mentioned in the Atom framwork&#8217;s introduction, Atom is actually inspired by Plotemy project <a href="http://ptolemy.eecs.berkeley.edu/index.htm">http://ptolemy.eecs.berkeley.edu/index.htm</a></p></div>
<div class="literalblock"><div class="content"><pre>but it actually tend to has various different goals, techniques, mindset and approaches. The comparasion in constrast with Ptolemy will reveal a lot of Atom characteristics.</pre></div></div>
<div class="literalblock"><div class="content"><pre> The Ptolemy project studies modeling, simulation, and design of concurrent, real-time, embedded systems. The focus is on assembly of concurrent components. The key underlying principle in the project is the use of well-defined models of computation that govern the interaction between components.A major problem area being addressed is the use of heterogeneous mixtures of models of computation.</pre></div></div>
<div class="paragraph"><p><strong>VS</strong></p></div>
<div class="literalblock"><div class="content"><pre> Atom is designed to **MAKE** concurrent, real-time, embedded systems and **GAMES**. So it focus more in code generation, profile, monitoring; focus more in graphics, physics, **player experience**... etc.   Underlying, it borrow quite a bunch of concepts that built in Ptolemy (not codes!).</pre></div></div>
<div class="sect3"><h4 id="goals">Goals</h4><div class="paragraph"><p>So the two projects' <strong>goals</strong> are quite overlapped but have different focus points and mindset!</p></div>
<div class="ulist"><ul><li><p>Atom has no or less concern/ interests about mathematic/ physics correctioness ( so simmulations) but the graphics side and overal behaviors.</p></li><li><p>Atom has open-source spirit… but not academic!! You can see Plotemy is quite “complicated and not very popular as it provided for academic first; in constrast, Atom is broadcasted for every one to use and to make games as kids in sandboxes.</p></li></ul></div></div>
<div class="sect3"><h4 id="techniques-differencies">Techniques differencies:</h4><div class="ulist"><ul><li><p>Atom not “just depend on well-defined models!</p></li><li><p>Atom use simplier models, …but sometime simplier is better!</p><div class="ulist"><ul><li><p>Simplier Entity model (not abstract out of Java object)</p></li><li><p>Actor model is not as abstrat also actually from threaded enviroment</p></li><li><p>No contract in Systems, the study of Systems conections and interactivities are though data-driven analysising only, that&#8217;s it, a dataflow monitoring system over working system.</p></li><li><p>Timming: Because of the lack of interests in math/ phycics, time model and precision model is undefined but also from Java platform.</p></li></ul></div></li><li><p>Those above and its core techniques that you can find below, lead Atom to be less independent from Java but also has well embeding characteristics of Java languages and run-time enviroments. So can say Atom is built directly on top of Java with no hesitate!</p></li></ul></div></div></div>
<div class="sect2"><h3 id="atom-vs-jscience">Atom VS JScience</h3><div class="paragraph"><p>Atom also depends in Javolution and has some parts from JScience code base but once again the purpose, Atom focus in Games and simulations… Also a lot of techniques Atom is different from one used in JScience.</p></div>
<div class="paragraph"><p>One can also see that Atom fullfill the lack of JScience&#8217;s experimental Game package. :)</p></div></div>
<div class="sect2"><h3 id="target-devices-platforms">Target Devices &amp; Platforms</h3><div class="sect3"><h4 id="pc">PC</h4></div>
<div class="sect3"><h4 id="mobile">Mobile</h4><div class="sect4"><h5 id="android">Android</h5></div></div>
<div class="sect3"><h4 id="web">Web</h4><div class="sect4"><h5 id="html5-and-webgl">HTML5 and WebGL</h5></div></div></div></div>
<div class="sect1"><h2 id="problems">Problems</h2><div class="sectionbody"></div></div>
<div class="sect1"><h2 id="solutions-frameworks-platforms">Solutions &amp; Frameworks &amp; Platforms</h2><div class="sectionbody"><div class="paragraph"><p>In Java, a lot good opensource projects are already provide solutions for various challanges in software developments. The problem is how to glue those gems together in appropriate way and result in efficient, good quality product - Saving time and efforts.</p></div>
<div class="admonitionblock warning"><table><tr><td class="icon"><i class="fa icon-warning" title="Warning"></i></td><td class="content"><div class="paragraph"><p>Hundred of opensource projects…</p></div></td></tr></table></div>
<div class="paragraph"><p>For example, AtomCore module depends in these high quality libraries:</p></div>
<div class="ulist"><ul><li><p>JME3</p></li><li><p>Common Java JSR annotations:</p></li><li><p>Apache commons</p><div class="ulist"><ul><li><p>Lang</p></li><li><p>Configurations</p></li><li><p>BeanUtils</p></li><li><p>Collections</p></li></ul></div></li><li><p>Google&#8217;s</p><div class="ulist"><ul><li><p>Guava:</p></li><li><p>Guice: Dependency injection</p></li><li><p>Snappy:</p></li><li><p>LevelDB</p></li><li><p>Auto</p></li></ul></div></li></ul></div>
<div class="paragraph"><p>*</p></div>
<div class="paragraph"><p>Other require pieces are write from sk</p></div></div></div>
<div class="sect2"><h3 id="atom-framework-design-course">Atom framework Design course</h3><div class="paragraph"><p>This section is dedicated to explain some idioms, patterns, and long term solutions for problems and each design goals, structures.</p></div>
<div class="sect2"><h3 id="game-and-real-time-application">Game and real-time application</h3><div class="sect3"><h4 id="cross-game-genre-elements">Cross game-genre elements</h4><div class="paragraph"><p>From an abstraction level, a Game- a special kind of software (almost always):</p></div>
<div class="ulist"><ul><li><p>composed by Entities, and their Stage;</p></li><li><p>where Actions happen in a Cycle, procedure Events;</p></li></ul></div>
<div class="paragraph"><p>A little bit more detailed, Gameplay is the way player play the Game, has:</p></div>
<div class="ulist"><ul><li><p>Logic:</p><div class="ulist"><ul><li><p>Trigger: in which Conditions, active some appropriate Action, as primitive brick.</p></li><li><p>Rule: the laws, restrictions form the game rule which player, entities obey.</p></li></ul></div></li><li><p>Routines: Situations/ Events/ Actions that happen in the game Cycle.</p><div class="ulist"><ul><li><p>Story/Cinematic mode: When player just watch the game like a movie.</p></li><li><p>Interactive mode: When player interact with the game world</p></li></ul></div></li><li><p>Control: The way player handle their entities</p></li><li><p>League:</p><div class="ulist"><ul><li><p>Single: Infos, score, rewards stick to an individual</p></li><li><p>Multi: The way players join, left, make friend and interactive and play together…</p></li></ul></div></li><li><p>Status: Way to pause/continue , save/load current game</p></li></ul></div>
<div class="paragraph"><p>The game “software should be published in specific enviroment, it then has:</p></div>
<div class="ulist"><ul><li><p>Configurations : appropriate settings for specific enviroment, device.</p></li><li><p>Data : appropriate size and format</p></li></ul></div></div>
<div class="sect3"><h4 id="cpu-gpu-interactions">CPU-GPU interactions</h4></div>
<div class="sect3"><h4 id="java-native-interactions">Java-Native interactions</h4></div>
<div class="sect3"><h4 id="timing">Timing</h4></div>
<div class="sect3"><h4 id="cycle">Cycle</h4></div></div>
<div class="sect2"><h3 id="atomcore-architecture">AtomCore Architecture</h3><div class="paragraph"><p>The Core is the part that focus in <strong>Game and real-time application</strong>. It declare</p></div>
<div class="paragraph"><p>You can read more about the Core architecture here.
<a href="../../../jme3/advanced/atom_framework/atomcore.html">atomcore</a></p></div></div>
<div class="sect2"><h3 id="design-patterns-programming-paradigms">Design patterns &amp; Programming paradigms</h3><div class="paragraph"><p>Consider research through this trusted resources before we go deeper into Atom architecture and where/why/how it apply each Design patterns:</p></div>
<div class="paragraph"><p><a href="../../../jme3/advanced/atom_framework/design/patterns.html">patterns</a></p></div></div>
<div class="sect2"><h3 id="programming-aspects">Programming aspects</h3><div class="sect3"><h4 id="java-but-not-just-java">Java, but not just Java</h4><div class="paragraph"><p>The most “Java things in AtomCore is Bean and Properties. Two pure Java data type which are very useful in Game world. Bean is for game object modeling and Properties for configuration.</p></div>
<div class="paragraph"><p>Of course, other Java technologies are also used but not mentioned because it&#8217;s not nessesary. But Bean and Properties are the two techs that heavily used!</p></div>
<div class="paragraph"><p>“Good Java extensions used in AtomCore 0.2+ is:
Guava:</p></div>
<div class="ulist"><ul><li><p>Bring Eventbus, network in a snap</p></li><li><p>Collection, Fluent, functional syntax and flavour to Java.</p></li><li><p>Guava also support Cache, reflection and more low level operations</p></li></ul></div>
<div class="paragraph"><p>Guice: bring Dependency injection, better unit test, refactoring in a lightweight manner.</p></div>
<div class="paragraph"><p>Groovy is a JVM language and intergrated deeply with AtomCore, most appreal as Scripting language but remember it also can replace Java, or seen as Java. Groovy also offer much more of superb things.</p></div></div>
<div class="sect3"><h4 id="code-vs-data">Code vs Data</h4><div class="paragraph"><p>For big game, the amount of Data required can be so much. Mean while the complexity of code also rise fast, as the result of data increasing!</p></div>
<div class="paragraph"><p>At some point, we have to find a solution to reduce “manual Data + code making and maintaining. That where “generative code also can be seen as a kind of Data was born. This called Data-driven architecture (solution). In AtomCore 0.2, it have features to support this trend.</p></div></div>
<div class="sect3"><h4 id="around-bean">Around Bean</h4><div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="paragraph"><p>This is so important to mention that every techs Atom framework are around Bean/ POJO technologies.</p></div></td></tr></table></div>
<div class="paragraph"><p>For example:</p></div>
<div class="ulist"><ul><li><p>AtomEX : the bridge to AKKA Actor model also use POJO as its candidate</p></li><li><p>EJB leverage…</p></li><li><p>Fx: use POJO as its effect elements</p></li></ul></div>
<div class="paragraph"><p>Here is a brief explaination why Bean/ POJO is choosed to be the Core of Atom framework?</p></div>
<div class="literalblock"><div class="content"><pre>As built in Java technologies, Bean/ POJO is the only "consider good" solution as:
**"the bridge"** **from Java OOP to COP**, **from Java OOP to AOP**</pre></div></div>
<div class="literalblock"><div class="content"><pre>also can be seen as
**from Object oriented programming to Data oriented programming**
**from Object oriented programming to Aspect oriented programming**</pre></div></div>
<div class="literalblock"><div class="content"><pre>or **Code but also Data**...</pre></div></div></div></div>
<div class="sect2"><h3 id="polygot-programming">Polygot programming</h3><div class="literalblock"><div class="content"><pre> I want Best of both worlds!!
 (.. if it's possible?)</pre></div></div>
<div class="paragraph"><p>Atom in its core try to be polymorphism (polygot programming), to suite with OOP, COP, AOP or functional … Yeah, it&#8217;s java after all but good kind of Java.</p></div>
<div class="paragraph"><p>Because AtomScripting and others use Groovy, so it inherit (a lot of) polygot capacity from Groovy.</p></div>
<div class="paragraph"><p>Read: <a href="http://groovy-lang.org/Polyglot+Programming+with+Groovy">http://groovy-lang.org/Polyglot+Programming+with+Groovy</a></p></div>
<div class="sect3"><h4 id="functional-reactive-programming">Functional reactive programming</h4></div>
<div class="sect3"><h4 id="flow-based-programming">Flow based programming</h4></div>
<div class="sect3"><h4 id="component-based-programming">Component based programming</h4></div>
<div class="sect3"><h4 id="composite-based-programming">Composite based programming</h4></div>
<div class="sect3"><h4 id="data-driven-model-driven-domain-driven">Data-driven &amp; Model-driven &amp; Domain-driven</h4></div></div>
<div class="sect2"><h3 id="modular-architecture">Modular architecture</h3><div class="literalblock"><div class="content"><pre> I want to reuse (or DRY)!!</pre></div></div>
<div class="paragraph"><p>Take a look at a JME3 game, Manager for example, what if you want the two manager&#8217;s work together but loosely depend on each other, or what if you want the State to direct the Manager to do something but have minimal informations about them…</p></div>
<div class="paragraph"><p>More abstract, whenever you have some kind of Service, which is loosely depend on each other, you should try Dependency Injection <a href="http://martinfowler.com/articles/injection.html">http://martinfowler.com/articles/injection.html</a> .</p></div>
<div class="paragraph"><p>That&#8217;s where Guice help in the big picture.</p></div>
<div class="sect3"><h4 id="dependency-injection">Dependency injection</h4><div class="paragraph"><p><a href="https://code.google.com/p/google-guice/">https://code.google.com/p/google-guice/</a></p></div></div>
<div class="sect3"><h4 id="component-injection">Component Injection</h4><div class="paragraph"><p><a href="http://wiki.apidesign.org/wiki/Component_Injection">http://wiki.apidesign.org/wiki/Component_Injection</a></p></div></div>
<div class="sect3"><h4 id="dependency-injection-vs-component-injection">Dependency injection VS Component Injection</h4><div class="paragraph"><p><a href="http://code.imagej.net/gbh/lookup/DependencyInjectionandLookup.html">http://code.imagej.net/gbh/lookup/DependencyInjectionandLookup.html</a></p></div></div>
<div class="sect3"><h4 id="dependency-management-coolness">Dependency management coolness</h4><div class="paragraph"><p>So what&#8217;s cool about dependency in real-time application and game that Atom included…
A lot of things, but let me point out fews:</p></div>
<div class="paragraph"><p><strong>Real-time dependency</strong> is a new feature for game developing…
Imagine that even the game just can load part of assets, with the other are delayed or missing, the dependency graph can help the game cycle continue to run, part of it in the mean time.</p></div>
<div class="paragraph"><p>In fact the dependency graph can be considered the topo structure of JME assets dependency graph before it built, means hard links via references. Now even when the assets graph are just partly loaded, the game can run because it know a resolution to safety resolve the assets graph and scene graph afterward.</p></div>
<div class="paragraph"><p><strong>Enterprise features</strong>
You can imagine how Atom framework tend to bridge JME game and the Web universal. It&#8217;s not so hard in fact. Cause Java enterprise technologies are already there to use. Lot of them are built on the top of Dependency injection and Inversion of control (or else)… I really like dependency injection but I can not agree that i should always couple with IoC per se. This will be discuss later in this documentation</p></div></div></div></div>
<div class="sect2"><h3 id="enterprise-facilities">Enterprise facilities</h3><div class="sect2"><h3 id="services-dependency-and-decoupling">Services, Dependency and Decoupling</h3><div class="paragraph"><p>The world of enteprise evolve Modular paradigm a lot to link services (database, configurations, network protocols, web…) and help they work together in one application.</p></div></div>
<div class="sect2"><h3 id="available-services">Available Services</h3><div class="paragraph"><p>Try AtomEx</p></div>
<div class="sect3"><h4 id="to-database">To Database</h4></div>
<div class="sect3"><h4 id="to-other-repository">To other repository</h4></div>
<div class="sect3"><h4 id="to-configurations">To configurations</h4></div>
<div class="sect3"><h4 id="to-web">To web</h4></div></div></div>
<div class="sect1"><h2 id="monitoring-and-development-workflow">Monitoring and development workflow</h2><div class="sectionbody"></div></div>
<div class="sect1"><h2 id="future-vision">Future vision</h2><div class="sectionbody"></div></div>
<div class="sect1"><h2 id="references-and-inspiration">References and Inspiration</h2><div class="sectionbody"><div class="paragraph"><p>Atom framework&#8217;s design is inspried by:</p></div>
<div class="ulist"><ul><li><p>Game Engine Architcture book</p></li><li><p>Game Programming gems serires</p></li><li><p>AI Game Engine book</p></li><li><p>AI Game Wisdom book</p></li></ul></div>
<div class="paragraph"><p>other GameEngine that I did use:</p></div>
<div class="ulist"><ul><li><p>UDK</p></li><li><p>Unity</p></li><li><p>CryEngineSDK</p></li><li><p>JavaScript game engines : CraftyJs, GameQuery ..</p></li><li><p>Flash game engines : Starling ,</p></li><li><p>… dozen of close-source engine.</p></li></ul></div>
<div class="paragraph"><p>other Java techs:</p></div>
<div class="ulist"><ul><li><p>EJB</p></li><li><p>Spring</p></li><li><p>Groovy</p></li><li><p>Netbean</p></li><li><p>… hunread of open-source projects</p></li></ul></div>
<div class="paragraph"><p>Full researched papers list are comming.</p></div></div></div></div><div id="footer"><div id="footer-text">Version <br>Last updated 2017-11-14 05:28:25 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>