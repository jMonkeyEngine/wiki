<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><meta name="keywords" content="documentation, physics, input, animation, character, NPC, collision"><title>Walking Character</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/jMonkeyEngine/wiki/edit/master/src/docs/asciidoc/jme3/advanced/walking_character.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/jMonkeyEngine/wiki/new/master/src/docs/asciidoc/jme3/advanced/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>Walking Character</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version ,</span> <span id="revdate">2016/03/17 20:48</span></div><div id="toc" class="toc2"><div id="toctitle">Table of Contents</div><ul class="sectlevel1"><li><a href="#sample-code">Sample Code</a></li><li><a href="#bettercharactercontrol">BetterCharacterControl</a></li><li><a href="#character-control">Character Control</a></li><li><a href="#walking-character-demo">Walking Character Demo</a><ul class="sectlevel2"><li><a href="#code-skeleton">Code Skeleton</a></li><li><a href="#overview">Overview</a></li><li><a href="#activate-physics">Activate Physics</a></li><li><a href="#initialize-the-scene">Initialize the Scene</a></li><li><a href="#create-the-animated-character">Create the Animated Character</a></li><li><a href="#set-up-animcontrol-and-animchannels">Set Up AnimControl and AnimChannels</a></li><li><a href="#add-chasecam-cameranode">Add ChaseCam / CameraNode</a></li><li><a href="#handle-navigation">Handle Navigation</a></li></ul></li><li><a href="#see-also">See also</a></li></ul></div></div><div id="content"><div id="preamble"><div class="sectionbody"><div class="paragraph"><p>In the <a href="../../jme3/beginner/hello_collision.html">Hello Collision</a> tutorial and the <a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestQ3.java">TestQ3.java</a> code sample you have seen how to create collidable landscapes and walk around in a first-person perspective. The first-person camera is enclosed by a collision shape and is steered by the BetterCharacterControl.</p></div>
<div class="paragraph"><p>Other games however require a third-person perspective of the character: In these cases you use a CharacterControl on a Spatial. This example also shows how to set up custom navigation controls, so you can press WASD to make the third-person character walk; and how to implement dragging the mouse to rotate.</p></div>
<div class="admonitionblock warning"><table><tr><td class="icon"><i class="fa icon-warning" title="Warning"></i></td><td class="content"><div class="paragraph"><p>Some details on this page still need to be updated from old CharacterControl <abbr title="Application Programming Interface">API</abbr> to BetterCharacterControl <abbr title="Application Programming Interface">API</abbr>.</p></div></td></tr></table></div></div></div>
<div class="sect1"><h2 id="sample-code">Sample Code</h2><div class="sectionbody"><div class="paragraph"><p>Several related code samples can be found here:</p></div>
<div class="ulist"><ul><li><p><a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestPhysicsCharacter.java">TestPhysicsCharacter.java</a> (third-person view)</p></li><li><p><a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestWalkingChar.java">TestWalkingChar.java</a> (third-person view)</p><div class="ulist"><ul><li><p>Uses also <a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/BombControl.java">BombControl.java</a></p></li></ul></div></li><li><p><a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestQ3.java">TestQ3.java</a> (first-person view)</p></li><li><p><a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/helloworld/HelloCollision.java">HelloCollision.java</a> (first-person view)</p></li></ul></div>
<div class="paragraph"><p>The code in this tutorial is a combination of these samples.</p></div></div></div>
<div class="sect1"><h2 id="bettercharactercontrol">BetterCharacterControl</h2><div class="sectionbody"><div class="paragraph"><p>Motivation: When you load a character model, give it a RigidBodyControl, and use forces to push it around, you do not get the desired behaviour: RigidBodyControl&#8217;ed objects (such as cubes and spheres) roll or tip over when pushed by physical forces. This is not the behaviour that you expect of a walking character. JME3&#8217;s BulletPhysics integration offers a BetterCharacterControl with a <code>setWalkDirection()</code> method. You use it to create simple characters that treat floors and walls as solid, and always stays locked upright while moving.</p></div>
<div class="paragraph"><p>This code sample creates a simple upright Character:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Load any model</span>
Node myCharacter = (Node) assetManager.loadModel(<span class="string"><span class="delimiter">&quot;</span><span class="content">Models/myCharacterModel.mesh.xml</span><span class="delimiter">&quot;</span></span>);
rootNode.attachChild(myCharacter);
<span class="comment">// Create a appropriate physical shape for it</span>
CapsuleCollisionShape capsuleShape = <span class="keyword">new</span> CapsuleCollisionShape(<span class="float">1.5f</span>, <span class="float">6f</span>, <span class="integer">1</span>);
CharacterControl myCharacter_phys = <span class="keyword">new</span> CharacterControl(capsuleShape, <span class="float">0.01f</span>);
<span class="comment">// Attach physical properties to model and PhysicsSpace</span>
myCharacter.addControl(myCharacter_phys);
bulletAppState.getPhysicsSpace().add(myCharacter_phys);</code></pre></div></div>
<div class="paragraph"><p>To use the BetterCharacterControl, you may load your character like this:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Load any model</span>
Spatial playerSpatial = assetManager.loadModel(<span class="string"><span class="delimiter">&quot;</span><span class="content">Models/Oto/Oto.mesh.xml</span><span class="delimiter">&quot;</span></span>);
player =  (Node)playerSpatial; <span class="comment">// You can set the model directly to the player. (We just wanted to explicitly show that it's a spatial.)</span>
Node playerNode = <span class="keyword">new</span> Node(); <span class="comment">// You can create a new node to wrap your player to adjust the location. (This allows you to solve issues with character sinking into floor, etc.)</span>
playerNode.attachChild(player); <span class="comment">// add it to the wrapper</span>
player.move(<span class="integer">0</span>,<span class="float">3.5f</span>,<span class="integer">0</span>); <span class="comment">// adjust position to ensure collisions occur correctly.</span>
player.setLocalScale(<span class="float">0.5f</span>); <span class="comment">// optionally adjust scale of model</span>
<span class="comment">// setup animation:</span>
        control = player.getControl(AnimControl.class);
        control.addListener(<span class="local-variable">this</span>);
        channel = control.createChannel();
        channel.setAnim(<span class="string"><span class="delimiter">&quot;</span><span class="content">stand</span><span class="delimiter">&quot;</span></span>);
playerControl = <span class="keyword">new</span> BetterCharacterControl(<span class="float">1.5f</span>, <span class="float">6f</span>, <span class="float">1f</span>); <span class="comment">// construct character. (If your character bounces, try increasing height and weight.)</span>
playerNode.addControl(playerControl); <span class="comment">// attach to wrapper</span>
<span class="comment">// set basic physical properties:</span>
        playerControl.setJumpForce(<span class="keyword">new</span> Vector3f(<span class="integer">0</span>,<span class="float">5f</span>,<span class="integer">0</span>));
        playerControl.setGravity(<span class="keyword">new</span> Vector3f(<span class="integer">0</span>,<span class="float">1f</span>,<span class="integer">0</span>));
playerControl.warp(<span class="keyword">new</span> Vector3f(<span class="integer">0</span>,<span class="integer">10</span>,<span class="integer">10</span>)); <span class="comment">// warp character into landscape at particular location</span>
<span class="comment">// add to physics state</span>
        bulletAppState.getPhysicsSpace().add(playerControl);
        bulletAppState.getPhysicsSpace().addAll(playerNode);
rootNode.attachChild(playerNode); <span class="comment">// add wrapper to root</span></code></pre></div></div></div></div>
<div class="sect1"><h2 id="character-control">Character Control</h2><div class="sectionbody"><div class="admonitionblock important"><table><tr><td class="icon"><i class="fa icon-important" title="Important"></i></td><td class="content"><div class="paragraph"><p>The BulletPhysics CharacterControl only collides with “real PhysicsControls (RigidBody). It does not detect collisions with other CharacterControls! If you need additional collision checks, add GhostControls to your characters and create a custom <a href="../../jme3/advanced/physics_listeners.html">collision listener</a> to respond.</p></div></td></tr></table></div>
<div class="paragraph"><p>A CharacterControl is a special kinematic object with restricted movement. CharacterControls have a fixed “upward axis, this means they do not topple over when walking over an obstacle (as opposed to RigidBodyControls), which simulates a being&#8217;s ability to balance upright. A CharacterControl can jump and fall along its upward axis, and it can scale steps of a certain height/steepness.</p></div>
<table class="tableblock frame-all grid-all spread"><colgroup><col style="width: 50%;"><col style="width: 50%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">CharacterControl Method</th><th class="tableblock halign-left valign-top">Property</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>setUpAxis(1)</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Fixed upward axis. Values: 0 = X axis , 1 = Y axis , 2 = Z axis.<br>
Default: 1, because for characters and vehicles, up is typically along the Y axis.</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>setJumpSpeed(10f)</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Jump speed (movement along upward-axis)</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>setFallSpeed(20f)</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Fall speed (movement opposite to upward-axis)</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>setMaxSlope(1.5f)</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>How steep the slopes and steps are that the character can climb without considering them an obstacle. Higher obstacles need to be jumped. Vertical height in world units.</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>setGravity(1f)</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>The intensity of gravity for this CharacterControl&#8217;ed entity. Tip: To change the direction of gravity for a character, modify the up axis.</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>setWalkDirection(new Vector3f(0f,0f,0.1f))</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>(CharacterControl only) Make a physical character walk continuously while checking for floors and walls as solid obstacles. This should probably be called “setPositionIncrementPerSimulatorStep. This argument is neither a direction nor a velocity, but the amount to increment the position each physics tick: vector length = accuracy*speed in m/s.<br>
Use <code>setWalkDirection(Vector3f.ZERO)</code> to stop a directional motion.</p></div></div></td></tr></tbody></table>
<div class="paragraph"><p>For best practices on how to use <code>setWalkDirection()</code>, see the Navigation Inputs example below.</p></div></div></div>
<div class="sect2"><h3 id="walking-character-demo">Walking Character Demo</h3><div class="sect2"><h3 id="code-skeleton">Code Skeleton</h3><div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">WalkingCharacterDemo</span> <span class="directive">extends</span> SimpleApplication
        <span class="directive">implements</span> <span class="predefined-type">ActionListener</span>, AnimEventListener {

  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
    WalkingCharacterDemo app = <span class="keyword">new</span> WalkingCharacterDemo();
    app.start();
  }

  <span class="directive">public</span> <span class="type">void</span> simpleInitApp() { }

  <span class="directive">public</span> <span class="type">void</span> simpleUpdate(<span class="type">float</span> tpf) { }

  <span class="directive">public</span> <span class="type">void</span> onAction(<span class="predefined-type">String</span> name, <span class="type">boolean</span> isPressed, <span class="type">float</span> tpf) { }

  <span class="directive">public</span> <span class="type">void</span> onAnimCycleDone(AnimControl control, AnimChannel channel, <span class="predefined-type">String</span> animName) { }

  <span class="directive">public</span> <span class="type">void</span> onAnimChange(AnimControl control, AnimChannel channel, <span class="predefined-type">String</span> animName) { }</code></pre></div></div></div>
<div class="sect2"><h3 id="overview">Overview</h3><div class="paragraph"><p>To create a walking character:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>(Unless you already have it) Activate physics in the scene by adding a <a href="../../jme3/advanced/physics.html">BulletAppState</a>.</p></li><li><p>Init the scene by loading the game level model (terrain or floor/buildings), and giving the scene a MeshCollisionShape.</p></li><li><p>Create the animated character:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Load an animated character model.</p></li><li><p>Add a CharacterControl to the model.</p></li></ol></div></li><li><p>Set up animation channel and controllers.</p></li><li><p>Add a ChaseCam or CameraNode.</p></li><li><p>Handle navigational inputs.</p></li></ol></div></div>
<div class="sect2"><h3 id="activate-physics">Activate Physics</h3><div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> BulletAppState bulletAppState;
...
public <span class="type">void</span> simpleInitApp() {
    bulletAppState = <span class="keyword">new</span> BulletAppState();
    <span class="comment">//bulletAppState.setThreadingType(BulletAppState.ThreadingType.PARALLEL);</span>
    stateManager.attach(bulletAppState);
    ...
}</code></pre></div></div></div>
<div class="sect2"><h3 id="initialize-the-scene">Initialize the Scene</h3><div class="paragraph"><p>In the simpleInitApp() method you initialize the scene and give it a MeshCollisionShape. The sample in the jme3 sources uses a custom helper class that simply creates a flat floor and drops some cubes and spheres on it:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> simpleInitApp() {
  ...
  PhysicsTestHelper.createPhysicsTestWorld(rootNode,
      assetManager, bulletAppState.getPhysicsSpace());
  ...</code></pre></div></div>
<div class="paragraph"><p>In a real game, you would load a scene model here instead of a test world. You can load a model from a local or remote zip file, and scale and position it:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> Node gameLevel;
..
public <span class="type">void</span> simpleInitApp() {
  ...
  <span class="comment">//assetManager.registerLocator(&quot;quake3level.zip&quot;, ZipLocator.class);</span>
  assetManager.registerLocator(
  <span class="string"><span class="delimiter">&quot;</span><span class="content">http://jmonkeyengine.googlecode.com/files/quake3level.zip</span><span class="delimiter">&quot;</span></span>,
    HttpZipLocator.class);
  MaterialList matList = (MaterialList) assetManager.loadAsset(<span class="string"><span class="delimiter">&quot;</span><span class="content">Scene.material</span><span class="delimiter">&quot;</span></span>);
  OgreMeshKey key = <span class="keyword">new</span> OgreMeshKey(<span class="string"><span class="delimiter">&quot;</span><span class="content">main.meshxml</span><span class="delimiter">&quot;</span></span>, matList);
  gameLevel = (Node) assetManager.loadAsset(key);
  gameLevel.setLocalTranslation(-<span class="integer">20</span>, -<span class="integer">16</span>, <span class="integer">20</span>);
  gameLevel.setLocalScale(<span class="float">0.10f</span>);
  gameLevel.addControl(<span class="keyword">new</span> RigidBodyControl(<span class="integer">0</span>));
  rootNode.attachChild(gameLevel);
  bulletAppState.getPhysicsSpace().addAll(gameLevel);
  ...</code></pre></div></div>
<div class="paragraph"><p>Also, add a light source to be able to see the scene.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">  AmbientLight light = <span class="keyword">new</span> AmbientLight();
  light.setColor(ColorRGBA.White.mult(<span class="integer">2</span>));
  rootNode.addLight(light);</code></pre></div></div></div>
<div class="sect2"><h3 id="create-the-animated-character">Create the Animated Character</h3><div class="paragraph"><p>You create an animated model, such as Oto.mesh.xml.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Place the “Oto model into the <code>assets/Models/Oto/</code> directory of your project.</p></li><li><p>Create the CollisionShape and adjust the capsule radius and height to fit your character model.</p></li><li><p>Create the CharacterControl and adjust the stepheight (here 0.05f) to the height that the character can climb up without jumping.</p></li><li><p>Load the visible model. Make sure its start position does not overlap with scene objects.</p></li><li><p>Add the CharacterControl to the model and register it to the physicsSpace.</p></li><li><p>Attach the visible model to the rootNode.</p></li></ol></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> CharacterControl character;
<span class="directive">private</span> Node model;
...
public <span class="type">void</span> simpleInitApp() {
  ...
  CapsuleCollisionShape capsule = <span class="keyword">new</span> CapsuleCollisionShape(<span class="float">3f</span>, <span class="float">4f</span>);
  character = <span class="keyword">new</span> CharacterControl(capsule, <span class="float">0.05f</span>);
  character.setJumpSpeed(<span class="float">20f</span>);
  model = (Node) assetManager.loadModel(<span class="string"><span class="delimiter">&quot;</span><span class="content">Models/Oto/Oto.mesh.xml</span><span class="delimiter">&quot;</span></span>);
  model.addControl(character);
  bulletAppState.getPhysicsSpace().add(character);
  rootNode.attachChild(model);
  ...</code></pre></div></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="fa icon-tip" title="Tip"></i></td><td class="content"><div class="paragraph"><p><strong>Did you know?</strong> A CapsuleCollisionShape is a cylinder with rounded top and bottom. A capsule rotated upright is a good collision shape for a humanoid character since its roundedness reduces the risk of getting stuck on obstacles.</p></div></td></tr></table></div></div>
<div class="sect2"><h3 id="set-up-animcontrol-and-animchannels">Set Up AnimControl and AnimChannels</h3><div class="paragraph"><p>Create several AnimChannels, one for each animation that can happen simultaneously. In this example, you create one channel for walking and one for attacking. (Because the character can attack with its arms and walk with the rest of the body at the same time.)</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> AnimChannel animationChannel;
<span class="directive">private</span> AnimChannel attackChannel;
<span class="directive">private</span> AnimControl animationControl;
...
public <span class="type">void</span> simpleInitApp() {
  ...
  animationControl = model.getControl(AnimControl.class);
  animationControl.addListener(<span class="local-variable">this</span>);
  animationChannel = animationControl.createChannel();
  attackChannel = animationControl.createChannel();
  attackChannel.addBone(animationControl.getSkeleton().getBone(<span class="string"><span class="delimiter">&quot;</span><span class="content">uparm.right</span><span class="delimiter">&quot;</span></span>));
  attackChannel.addBone(animationControl.getSkeleton().getBone(<span class="string"><span class="delimiter">&quot;</span><span class="content">arm.right</span><span class="delimiter">&quot;</span></span>));
  attackChannel.addBone(animationControl.getSkeleton().getBone(<span class="string"><span class="delimiter">&quot;</span><span class="content">hand.right</span><span class="delimiter">&quot;</span></span>));
  ...</code></pre></div></div>
<div class="paragraph"><p>The attackChannel only controls one arm, while the walking channels controls the whole character.</p></div></div>
<div class="sect2"><h3 id="add-chasecam-cameranode">Add ChaseCam / CameraNode</h3><div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> ChaseCamera chaseCam;

...

public <span class="type">void</span> simpleInitApp() {
  ...
  flyCam.setEnabled(<span class="predefined-constant">false</span>);
  chaseCam = <span class="keyword">new</span> ChaseCamera(cam, model, inputManager);
  ...</code></pre></div></div></div>
<div class="sect2"><h3 id="handle-navigation">Handle Navigation</h3><div class="paragraph"><p>Configure custom key bindings for WASD keys that you will use to make the character walk. Then calculate the vector where the user wants the character to move. Note the use of the special <code>setWalkDirection()</code> method below.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// track directional input, so we can walk left-forward etc</span>
<span class="directive">private</span> <span class="type">boolean</span> left = <span class="predefined-constant">false</span>, right = <span class="predefined-constant">false</span>, up = <span class="predefined-constant">false</span>, down = <span class="predefined-constant">false</span>;
...

public <span class="type">void</span> simpleInitApp() {
  ...
  <span class="comment">// configure mappings, e.g. the WASD keys</span>
  inputManager.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharLeft</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> KeyTrigger(KeyInput.KEY_A));
  inputManager.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharRight</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> KeyTrigger(KeyInput.KEY_D));
  inputManager.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharForward</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> KeyTrigger(KeyInput.KEY_W));
  inputManager.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharBackward</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> KeyTrigger(KeyInput.KEY_S));
  inputManager.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharJump</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> KeyTrigger(KeyInput.KEY_RETURN));
  inputManager.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharAttack</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> KeyTrigger(KeyInput.KEY_SPACE));
  inputManager.addListener(<span class="local-variable">this</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CharLeft</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CharRight</span><span class="delimiter">&quot;</span></span>);
  inputManager.addListener(<span class="local-variable">this</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CharForward</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CharBackward</span><span class="delimiter">&quot;</span></span>);
  inputManager.addListener(<span class="local-variable">this</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CharJump</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">CharAttack</span><span class="delimiter">&quot;</span></span>);
  ...
}</code></pre></div></div>
<div class="paragraph"><p>Respond to the key bindings by setting variables that track in which direction you will go. This allows us to steer the character forwards and to the left at the same time. <strong>Note that no actual walking happens here yet!</strong> We just track the input.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">void</span> onAction(<span class="predefined-type">String</span> binding, <span class="type">boolean</span> value, <span class="type">float</span> tpf) {
  <span class="keyword">if</span> (binding.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharLeft</span><span class="delimiter">&quot;</span></span>)) {
      <span class="keyword">if</span> (value) left = <span class="predefined-constant">true</span>;
      <span class="keyword">else</span> left = <span class="predefined-constant">false</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (binding.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharRight</span><span class="delimiter">&quot;</span></span>)) {
      <span class="keyword">if</span> (value) right = <span class="predefined-constant">true</span>;
      <span class="keyword">else</span> right = <span class="predefined-constant">false</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (binding.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharForward</span><span class="delimiter">&quot;</span></span>)) {
      <span class="keyword">if</span> (value) up = <span class="predefined-constant">true</span>;
      <span class="keyword">else</span> up = <span class="predefined-constant">false</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (binding.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharBackward</span><span class="delimiter">&quot;</span></span>)) {
      <span class="keyword">if</span> (value) down = <span class="predefined-constant">true</span>;
      <span class="keyword">else</span> down = <span class="predefined-constant">false</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (binding.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharJump</span><span class="delimiter">&quot;</span></span>))
      character.jump();
  <span class="keyword">if</span> (binding.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">CharAttack</span><span class="delimiter">&quot;</span></span>))
    attack();
}</code></pre></div></div>
<div class="paragraph"><p>The player can attack and walk at the same time. <code>Attack()</code> is a custom method that triggers an attack animation in the arms. Here you should also add custom code to play an effect and sound, and to determine whether the hit was successful.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="type">void</span> attack() {
    attackChannel.setAnim(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dodge</span><span class="delimiter">&quot;</span></span>, <span class="float">0.1f</span>);
    attackChannel.setLoopMode(LoopMode.DontLoop);
}</code></pre></div></div>
<div class="paragraph"><p>Finally, the update loop looks at the directional variables and moves the character accordingly. Since this is a special kinematic CharacterControl, we use the <code>setWalkDirection()</code> method.</p></div>
<div class="paragraph"><p>The variable <code>airTime</code> tracks how long the character is off the ground (e.g. when jumping or falling) and adjusts the walk and stand animations acccordingly.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> Vector3f walkDirection = <span class="keyword">new</span> Vector3f(<span class="integer">0</span>,<span class="integer">0</span>,<span class="integer">0</span>); <span class="comment">// stop</span>

<span class="directive">private</span> <span class="type">float</span> airTime = <span class="integer">0</span>;

<span class="directive">public</span> <span class="type">void</span> simpleUpdate(<span class="type">float</span> tpf) {
  Vector3f camDir = cam.getDirection().clone();
  Vector3f camLeft = cam.getLeft().clone();
  camDir.y = <span class="integer">0</span>;
  camLeft.y = <span class="integer">0</span>;
  camDir.normalizeLocal();
  camLeft.normalizeLocal();
  walkDirection.set(<span class="integer">0</span>, <span class="integer">0</span>, <span class="integer">0</span>);

  <span class="keyword">if</span> (left)  walkDirection.addLocal(camLeft);
  <span class="keyword">if</span> (right) walkDirection.addLocal(camLeft.negate());
  <span class="keyword">if</span> (up) walkDirection.addLocal(camDir);
  <span class="keyword">if</span> (down) walkDirection.addLocal(camDir.negate());

  <span class="keyword">if</span> (!character.onGround()) { <span class="comment">// use !character.isOnGround() if the character is a BetterCharacterControl type.</span>
      airTime += tpf;
  } <span class="keyword">else</span> {
      airTime = <span class="integer">0</span>;
  }

  <span class="keyword">if</span> (walkDirection.lengthSquared() == <span class="integer">0</span>) { <span class="comment">//Use lengthSquared() (No need for an extra sqrt())</span>
      <span class="keyword">if</span> (!<span class="string"><span class="delimiter">&quot;</span><span class="content">stand</span><span class="delimiter">&quot;</span></span>.equals(animationChannel.getAnimationName())) {
        animationChannel.setAnim(<span class="string"><span class="delimiter">&quot;</span><span class="content">stand</span><span class="delimiter">&quot;</span></span>, <span class="float">1f</span>);
      }
  } <span class="keyword">else</span> {
      character.setViewDirection(walkDirection);
      <span class="keyword">if</span> (airTime &gt; <span class="float">.3f</span>) {
        <span class="keyword">if</span> (!<span class="string"><span class="delimiter">&quot;</span><span class="content">stand</span><span class="delimiter">&quot;</span></span>.equals(animationChannel.getAnimationName())) {
          animationChannel.setAnim(<span class="string"><span class="delimiter">&quot;</span><span class="content">stand</span><span class="delimiter">&quot;</span></span>);
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string"><span class="delimiter">&quot;</span><span class="content">Walk</span><span class="delimiter">&quot;</span></span>.equals(animationChannel.getAnimationName())) {
        animationChannel.setAnim(<span class="string"><span class="delimiter">&quot;</span><span class="content">Walk</span><span class="delimiter">&quot;</span></span>, <span class="float">0.7f</span>);
      }
    }

  walkDirection.multLocal(<span class="float">25f</span>).multLocal(tpf);<span class="comment">// The use of the first multLocal here is to control the rate of movement multiplier for character walk speed. The second one is to make sure the character walks the same speed no matter what the frame rate is.</span>
  character.setWalkDirection(walkDirection); <span class="comment">// THIS IS WHERE THE WALKING HAPPENS</span>
}</code></pre></div></div>
<div class="paragraph"><p>This method resets the walk animation.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> onAnimCycleDone(AnimControl control, AnimChannel channel, <span class="predefined-type">String</span> animName) {
        <span class="keyword">if</span> (channel == attackChannel) channel.setAnim(<span class="string"><span class="delimiter">&quot;</span><span class="content">stand</span><span class="delimiter">&quot;</span></span>);
}

<span class="directive">public</span> <span class="type">void</span> onAnimChange(AnimControl control, AnimChannel channel, <span class="predefined-type">String</span> animName) { }</code></pre></div></div></div></div>
<div class="sect1"><h2 id="see-also">See also</h2><div class="sectionbody"><div class="ulist"><ul><li><p><a href="https://hub.jmonkeyengine.org/t/bettercharactercontrol-in-the-works/25242">https://hub.jmonkeyengine.org/t/bettercharactercontrol-in-the-works/25242</a></p></li></ul></div></div></div></div><div id="footer"><div id="footer-text">Version <br>Last updated 2017-11-14 05:28:25 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>